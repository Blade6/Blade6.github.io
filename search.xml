<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Maximum Subarray]]></title>
      <url>http://blade6.top/posts/b8913e5e/</url>
      <content type="text"><![CDATA[给定数组，求数组中的所有子串中最大的子串和。很容易就能想到O(n^3)的算法，一个一个遍历，但一定会超时的。下面介绍两种方法，第一种的时间复杂度为O(NlgN)，但是仍然超时，第二种为O(N)。 分治法解题思路对于给定数组，可以把该数组分成两部分，左半部分和右半部分。对于该数组的最大的子串和，要么出现在左半部分，要么出现在右半部分，要么出现在左半部分和右半部分的交叉部分。对于交叉部分，一定是从中间向两侧扩散的，写代码的时候要注意这一点。 代码如下1234567891011121314151617181920212223242526272829public class Solution &#123; public int maxSubArray(int[] nums) &#123; return maxSum(nums, 0, nums.length-1); &#125; public int maxSum(int[] nums, int left, int right) &#123; if (left == right) return nums[left]; int center = (left + right) / 2; int maxLeft = maxSum(nums, left, center); int maxRight = maxSum(nums, center+1, right); int maxLeftBorder = nums[center], leftBorder = nums[center]; for (int i = center-1; i &gt;= left; i--) &#123; leftBorder += nums[i]; if (leftBorder &gt; maxLeftBorder) maxLeftBorder = leftBorder; &#125; int maxRightBorder = nums[center+1], rightBorder = nums[center+1]; for (int j = center+2; j &lt;= right; j++) &#123; rightBorder += nums[j]; if (rightBorder &gt; maxRightBorder) maxRightBorder = rightBorder; &#125; return Math.max(Math.max(maxLeft, maxRight), maxLeftBorder+maxRightBorder); &#125;&#125; 循环的结束条件只判断了left==right的情况，left&gt;right的情况是不会出现的，利用反证法可以轻易证明，此处不展开叙述。 但是提交后仍然超时了。善良的leetcode在结果页面上告诉了我202个Testcase都通过了，代码本身是正确的，只是用时过长。 一次扫描法解题思路因为leetcode对题目做了限定，返回的最大子串和所在的子串至少包含一个数，换言之数组中所有数都是负数的情况下，最大子串和必然是最大的那个负数，这就是情况1。情况2：当所有数都是非负数，最大子串和就是数组中所有数的和。情况3：当输入的数组有正数有负数时，令max=0，temp=0，max表示最大子串和，因为数组中有正数，所以max的值会在循环中被改变，不会一直保持为0。temp表示当前的子串和。令指针i初始时指向数组第一个元素，i每次向后移动一位。对于i当前指向的元素，把它加到temp里。然后判断temp和max的大小，决定是否把temp的值赋给max。如果temp&lt;max时，还要判断temp的值是否小于0，如果小于0，则temp=0，表示舍弃temp所表示的子串，从该子串的下一个数开始求最大子串和，此处可以用反证法证明如下：若temp表示从下标m到n的子串和，假设我们最终求得的最大子串和MAX是从下标m到n+p的子串的和。那么MAX=temp+nums[n+1]+...+nums[n+p]，而又因为temp&lt;0，则存在REAL_MAX=nums[n+1]+...+nums[n+p]&gt;MAX，这与假设矛盾。 情况2和情况3可以一起处理，情况1需要特殊处理。 代码123456789101112131415161718192021222324public class Solution &#123; public int maxSubArray(int[] nums) &#123; int max = 0, temp = 0; boolean flag = false; for (int i = 0; i &lt; nums.length; i++) &#123; temp += nums[i]; if (temp &gt; max) max = temp; else if (temp &lt; 0) temp = 0; //如果数组中存在非负数，且flag为false的话， //flag置为true表示数组中存在非负数 if (!flag &amp;&amp; nums[i] &gt;= 0) flag = true; &#125; if (flag) return max; else &#123; int N_max = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i] &gt; N_max) N_max = nums[i]; &#125; return N_max; &#125; &#125;&#125; 提交后代码AC了，运行速度排名在67%左右。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Generate Parentheses]]></title>
      <url>http://blade6.top/posts/c59bb016/</url>
      <content type="text"><![CDATA[给定n，求n对括号可以生成的括号嵌套种数。这道题其实不难，很快就能想出解题思路。 解题思路对于n，记录的是括号的数目，本质上也是左括号和右括号的出现次数。假设t记录左括号的剩余出现次数，cur记录当前未匹配的左括号个数，str记录单次结果，str的长度是固定的，必然是2n。首先要初始化：t=n，cur=0，str=””。当循环开始时，第1个符号必须是左括号，然后t-=1，表示左括号的剩余出现次数变成n-1了。同时str+=”(“，cur+=1，表示str中有1个左括号未匹配。对于第i个符号：如果t==0且cur==0，说明循环结束，将str加到结果集中。如果t==0，说明左括号的剩余出现次数已用完，那么第i个符号只能取右括号，同时cur-=1；如果cur==0，说明str中不存在未匹配的左括号，那么第i个符号只能取左括号，同时t-=1；如果t&gt;0且cur&gt;0，则第i个符号可以是左括号也可以是右括号，如果第i个符号取左括号，那么t-=1，cur+=1，如果第i个符号取右括号，那么cur-=1。注意：因为对于第i个符号，当t&gt;0且cur&gt;0的时候，第i个符号可以有两种取值，所以使用递归会取得事半功倍的效果。 代码1234567891011121314151617181920public class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; l = new ArrayList&lt;String&gt;(); test(l, n, 0, ""); return l; &#125; public void test(List&lt;String&gt; l, int t, int cur, String str)&#123; if(t==0 &amp;&amp; cur == 0)&#123; l.add(str); &#125;else if(cur == 0)&#123; test(l, t-1, cur+1, str+"("); &#125;else if(t==0)&#123; test(l, t, cur-1, str+")"); &#125;else&#123; test(l, t-1, cur+1, str+"("); test(l, t, cur-1, str+")"); &#125; &#125;&#125; 一次AC通过，运行速度排名39%。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Merge Two Sorted Lists]]></title>
      <url>http://blade6.top/posts/a72883c7/</url>
      <content type="text"><![CDATA[合并两个有序链表。因为是链表，所以可以写出空间复杂度为O(1)的算法。 解题思路对于这两条链表，给定指针l1和l2，分别指向两条链表的结点。给定指针result，指向结果链表的尾结点。每次比较l1指向结点和l2指向结点的值的大小，然后把小的那个结点插入到结果链表的尾部，同时使存储该结点的指针指向其下一个结点，结果链表的指针result指向下一个结点。注意result每次都指向结果链表的尾结点，而不是尾结点的next部，否则会导致空指针错误。操作如图：橙色为上一步，蓝色为下一步。 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1 == null) return l2; if(l2 == null) return l1; //对于两个链表的第一个结点的比较单独写出来， //因为需要初始化result_head，result_head指向结果链表的第一个结点 ListNode result = null; if(l1.val &lt;= l2.val) &#123; result = l1; l1 = l1.next; &#125; else &#123; result = l2; l2 = l2.next; &#125; ListNode result_head = result; while(true) &#123; if(l1 == null) &#123; result.next = l2; break; &#125; else if (l2 == null) &#123; result.next = l1; break; &#125; else &#123; if(l1.val &lt;= l2.val) &#123; result.next = l1; l1 = l1.next; &#125; else &#123; result.next = l2; l2 = l2.next; &#125; result = result.next; &#125; &#125; return result_head; &#125; &#125; 提交后AC，运行速度排名60%左右。 还可以使用分治法，可以写出简短易懂的代码。1234567891011121314public class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1 == null) return l2; if(l2 == null) return l1; if(l1.val &lt;= l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Pow(x,n)]]></title>
      <url>http://blade6.top/posts/bbe3cb45/</url>
      <content type="text"><![CDATA[这道题是实现内置函数pow(x,n)。思路没什么复杂的，我很快就想出了第一个答案：123456789101112131415161718public class Solution &#123; public double myPow(double x, int n) &#123; if (n == 0) return 1.0; if (n == 1) return x; int m = n; if(n &lt; 0) m = -n; double result = x; while(m &gt; 1) &#123; result *= x; --m; &#125; if(n &lt; 0) return 1 / result; return result; &#125;&#125; 然后也很快地死在以下TestCase：0.000012147483647死亡原因：超时。 超时的原因很简单，我的算法是一个O(n)级别的算法。而事实上存在O(log n)级别的算法。所以，分治法出场了。 解题思想对于x^n，通常可以这样做：如果n是奇数，那么x^n等价于(x*x)^(n/2)*x;如果n是偶数，那么x^n等价于(x*x)^(n/2). 有了思想，很快就写出了代码：123456789101112131415public class Solution &#123; public double myPow(double x, int n) &#123; if(n == 0) return 1.0; if(n == 1) return x; if(n &lt; 0) return 1 / My_pow(x, -n); else return My_pow(x, n); &#125; public double My_pow(double x, int m) &#123; if(m == 1) return x; if(m % 2 == 0) return My_pow(x*x, m/2); return My_pow(x*x, m/2) * x; &#125;&#125; 提交后死在以下TestCase上：1.00000-2147483648死亡原因：运行时错误（栈溢出）P.S.仔细一看，就能发现错误。但当时我没有意识到。后来我修改了My_pow()方法，在第一行加上了if (m == 0) return 1.0;，提交后就AC了，运行速度排名70%左右。 当时看到栈溢出的错误时，我第一感觉是使用了递归导致的，于是试图实现使用循环代替递归，但是以失败告终。经过在网上搜索，对比别人的代码，我修改代码如下：1234567891011121314151617public class Solution &#123; public double myPow(double x, int n) &#123; if(n == 0) return 1.0; if(n == 1) return x; if(n == Integer.MIN_VALUE) return 1 / (My_pow(x, Integer.MAX_VALUE) * x); if(n &lt; 0) return 1 / My_pow(x, -n); else return My_pow(x, n); &#125; public double My_pow(double x, int m) &#123; if(m == 0) return 1.0; if(m == 1) return x; double half = My_pow(x, m/2); return half * half * My_pow(x, m%2); &#125;&#125; 提交后AC了，运行速度排名44%。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ZigZag Conversion]]></title>
      <url>http://blade6.top/posts/6d08e17c/</url>
      <content type="text"><![CDATA[一开始看到题目的时候，我是搞不清楚情况的。主要原因是不明白ZigZag的意思。 ZigZag比如有数字序列0,1,2,3，…，12，按照ZigZag排序如下：1230 4 8 121 3 5 7 9 112 6 10 ZigZag的含义就是锯齿形的，之字形的，Z字形的。现在问题明白了，给定字符串s和行数numRows，把字符串按照ZigZag排列，然后逐行按列读取，形成一个新的字符串，返回这个字符串。 解题思路这道题其实就是找规律。找到规律，代码写起来也很快。那么规律是什么呢？通过实例来捋一捋：对于给定的字符串s，它的每一个字符都应该有一个下标，这样就会形成一个下标序列，从0到s.length()-1。假设我们现在有0到20这21个数，是某个字符窜的下标序列。如果给定的numRows=6，那么把这个字符串按照ZigZag排列应该如下：1234560 10 201 9 11 192 8 12 183 7 13 174 6 14 165 15 规律如下：对于每一行的首个元素，其实是很好确定的，就是从0到numRows-1;对于首行和末行，每一个数都恰好是其前一个数加上2numRows-2;对于中间行，分成奇数位元素和偶数位元素处理，对于奇数位元素，每一个数都恰好是其前一个数加上2numRows-2，偶数位元素也是如此。 思路捋顺了，规律找到了，我们开始写代码：123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; public String convert(String s, int numRows) &#123; int length = s.length(); if (length == 1 || numRows == 1 || numRows &gt;= length) return s; StringBuilder result = new StringBuilder(); for (int i = 0; i &lt; numRows; i++) &#123; result.append(s.charAt(i)); if (i == 0 || i == numRows - 1) &#123; int j = i + 2 * numRows - 2; while (j &lt; length) &#123; result.append(s.charAt(j)); j += 2 * numRows - 2; &#125; &#125; else &#123; //int Odd = (numRows - 1) + [(numRows -1) - i] int Odd = 2 * numRows - 2 - i; if (Odd &lt; length) result.append(s.charAt(Odd)); int Even = i + 2 * numRows - 2; if (Even &lt; length) result.append(s.charAt(Even)); while (true) &#123; Odd += 2 * numRows - 2; if (Odd &lt; length) result.append(s.charAt(Odd)); else break; Even += 2 * numRows - 2; if (Even &lt; length) result.append(s.charAt(Even)); else break; &#125; &#125; &#125; return result.toString(); &#125; &#125; 需要注意的地方如下：1.对于字符串s，考虑s的长度小于numRows的情况。2.对于每次处理到的下标，除非当前下标是每一行的首个元素，否则需要判断该下标是否越界。3.中间行的奇数位元素的首个元素需要结合当前行进行判断。 提交代码，AC，运行时间53ms，排名84%。这次运气不错，一次运行通过。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Median of Two Sorted Arrays]]></title>
      <url>http://blade6.top/posts/757ce68a/</url>
      <content type="text"><![CDATA[要求出两个有序数组的中位数，试想，如果我们能够求出两个有序数组合并后的第k个数，那么中位数只是一种特殊情况，问题迎刃而解。题目要求时间复杂度要在O(log(m+n))，通常出现对数，应该考虑分治法。 解题思路求解两个有序数组的第k个数：假设给定有序数组A和B,A的前指针aLow和后指针aHigh，B的前指针bLow和bHigh，以及k。求出A数组区间[aLow,aHigh]的中间数A[aMid]，B也做同样操作，同时求出A[aLow,aMid]和B[bLow,bMid]一共有多少个数并赋给HalfPart注意是闭区间，所以A[aMid]和B[bMid]都包含在HalfPart里面，HalfPart=A[aLow,aMid]+B[bLow,bMid]。 然后判断A[aMid]和B[bMid]的大小。如果A[aMid]==B[bMid]，那么判断HalfPart和k的大小。HalfPart&gt;k说明第k个数应该出现在A[aLow,aMid]和B[bLow,bMid]所包含的数里，否则出现在A[aMid+1,aHigh]和B[bMid+1,bHigh]所包含的数里。如果A[aMid]!=B[bMid]，那么也是同样判断HalfPart和k的大小。当A[aMid]k，则说明第k个数不会出现在B[bMid,bHigh]里面，但无法判断第k个数在A中的出现情况。理由如下：如果A[aMid]&lt;B[bMid]&amp;&amp;HalfPart&gt;k，那么我们可以增加一个变量x=aMid，令x自增，直至A[x]==B[bMid]，假设把这两个有序数组进行合并的话，B[bMid]应该出现在x+bMid这个位置上,因为HalfPart&gt;k，同时又有x&gt;aMid，则易知x+bMid=A[aLow,x]+B[bLow,bMid]&gt;HalfPart&gt;k，则B[bMid]是一个合并排序后的第k+u个数（u是未知数），而我们要求的是第k个数，所以第k个数不会出现在B[bMid,bHigh]里面。第k个数有可能出现在A[aLow,x]和B[bLow,bMid-1]这个范围里面。如果HalfPart&lt;=k，则说明第k个数不会出现在A[aLow,aMid]里面，但无法判断在B中的出现情况。理由类似上述。P.S.注意当HalfPart&gt;k时，舍弃了B[bLow,bHigh]，舍弃的是高下标的数据，不会影响我们查找第k个数。但是当HalfPart&lt;=k时，舍弃的是A[aLow,aMid]，这实际修正了我们的查找目标，不再是第k个数，而是第k-(aMid-aLow+1)个数。对于A[aMid]&gt;B[bMid]的情况，相当于互换了A和B的位置，思路还是一样。 分析完毕，可以开始写代码了。1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int length = nums1.length + nums2.length; if (length % 2 == 0) return (findKth(nums1, nums2, length / 2) + findKth(nums1, nums2, length / 2 + 1)) / 2.0; else return findKth(nums1, nums2, (length + 1) / 2); &#125; /* * find the k num in two sorted arrays * recursion */ public int findK(int[] A, int a_low, int a_high, int[] B, int b_low, int b_high, int k) &#123; if (a_low &gt; a_high) return B[b_low + k - 1]; if (b_low &gt; b_high) return A[a_low + k - 1]; //if (a_high == a_low &amp;&amp; b_high == b_low &amp;&amp; A[a_low] == B[b_low]) return A[a_low]; int a_mid = a_low + (a_high - a_low) / 2; int b_mid = b_low + (b_high - b_low) / 2; int half_part = a_mid - a_low + b_mid - b_low + 2; if (A[a_mid] == B[b_mid]) &#123; if (half_part &lt; k) return findK(A, a_mid + 1, a_high, B, b_mid + 1, b_high, k - half_part); else return findK(A, a_low, a_mid, B, b_low, b_mid, k); &#125; else if (A[a_mid] &lt; B[b_mid] ) &#123; if (half_part &lt;= k) return findK(A, a_mid + 1, a_high, B, b_low, b_high, k - (a_mid - a_low + 1)); else return findK(A, a_low, a_high, B, b_low, b_mid - 1, k); &#125; else &#123; if (half_part &lt;= k) return findK(A, a_low, a_high, B, b_mid + 1, b_high, k - (b_mid - b_low + 1)); else return findK(A, a_low, a_mid - 1, B, b_low, b_high, k); &#125; &#125;&#125; 运行代码死在了以下TestCase：[1][1]死亡原因：运行错误，经本地调试发现是栈溢出。实际上是由于代码第26行造成的，死循环最终导致栈溢出。修正方法：将第18行的注释去掉。当两个数组都只剩一个数，且两数组的剩下的数还是同一个数时，则返回这个数。修正后AC通过，运行速度排名45%。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[3Sum]]></title>
      <url>http://blade6.top/posts/92e6a03a/</url>
      <content type="text"><![CDATA[3数和为0问题，对于这个问题，网上一致认为，这个问题是两数和问题的升级版，最终能够优化到O(n^2)级别。 解题思路对于给定数组中的每个下标i，用前指针left指向其下一个数，后指针right指向数组最后的数。如果三个数的和为0，则判断结果是否已出现，如果出现过，不添加，否则添加到结果集。如果三数和小于0，则前指针指向后一个数，否则后指针指向前一个数。根据解题思路，结合网上找到的别人的代码，我迅速地写出了第一个答案：123456789101112131415161718192021222324252627282930313233343536373839public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Arrays.sort(nums); int length = nums.length; for (int i = 0; i &lt; length; i++) &#123; int left = i + 1; int right = length - 1; while (left &lt; right) &#123; int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(nums[i]); list.add(nums[left]); list.add(nums[right]); if (!Compare(result, list)) result.add(list); ++left; --right; &#125; else if (sum &lt; 0) &#123; ++left; &#125; else &#123; --right; &#125; &#125; &#125; return result; &#125; public boolean Compare(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; list) &#123; for(int i = 0; i &lt; result.size(); i++) &#123; List&lt;Integer&gt; test = result.get(i); if (test.contains(list.get(0)) &amp;&amp; test.contains(list.get(1)) &amp;&amp; test.contains(list.get(2))) return true; &#125; return false; &#125; &#125; 通过Compare方法去重。然后死在了以下TestCase：[-4,-2,1,-5,-4,-4,4,-2,0,4,0,-2,3,1,-5,0]死亡原因：程序运行的结果集不正确，缺少[0,0,0]。我自个分析，原因在于Compare方法有错误，如果有一个结果（比如：[-4,4,0]）包含0和两个相反数，则[0,0,0]无法添加到结果集。而且这个方法需要对结果集做一个遍历，效率太低。 自己的代码too young too naive,我决定模仿现成的代码，从网上找到一段代码，Submit：123456789101112131415161718192021222324252627282930public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Arrays.sort(nums); int length = nums.length; for (int i = 0; i &lt; length; i++) &#123; int left = i + 1; int right = length - 1; while (left &lt; right) &#123; int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(nums[i]); list.add(nums[left]); list.add(nums[right]); result.add(list); ++left; --right; &#125; else if (sum &lt; 0) &#123; ++left; &#125; else &#123; --right; &#125; &#125; &#125; Set set = new HashSet&lt;&gt;(result); result = new ArrayList&lt;List&lt;Integer&gt;&gt;(set); return result; &#125;&#125; 这次313个TestCase，死在了第313个，也就是最后一个变态TestCase上：[0,…,0]0的出现次数有数千次之多。。死亡原因：Time Limit Exceeded 这个方法的优点自然是利用集合的无序性来达到去重的效果。缺点则是这是一个事后弥补的方法。对于每次得出的结果，则将该结果加入结果集。最后再对结果集进行筛选去重。为什么不在加入前先去重？ 根据这个TestCase，经过一番反省后，我想出两种办法来去重，第一种是采用过滤方法，第二种是备忘录方法。过滤方法的原理是，对于给定数组nums，如果其中有一个数出现了三次，那么除非这个数是0，否则第三次出现是没有意义的，因为我们最多也只会用到两个。举例来说：[4,-2,-2,-2]三数和为0的结果为[4,-2,-2]，-2在nums中出现了三次，其实出现两次就已经能得到结果[4,-2,-2]了，所以第三个-2是无效的。但0是可以出现三次的。对于任意数，出现了三次以上，就会有很多无效的数，这些数不会改变最终结果，但却会耗费大量运算时间。可以通过对nums进行过滤，剔除出现次数在3次以上的数，使得其出现次数减少至2次，0可以保持3次。第二种方法是备忘录方法，因为最终求和是nums[i]+nums[left]+nums[right]，nums[left]+nums[right]其实存在重复运算的可能性，说不定能存起来，以便下次调用，减少运算次数，但这样一想，感觉方法要走向动态规划了。 这两个idea都是在对nums做过滤，避免因为某个数的出现次数过多而做无用功，在一定程度上能够减少运算次数。但是回到问题本身，问题里给出了一个TestCase：[-1, 0, 1, 2, -1, -4]，上面的两个idea最终都会使输入的数组变成类似这样的形式（任意一个数的出现次数不会超过2次，0可以出现3次）。但这不是最优的形式。因为即使是这样的形式，还是存在重复运算。比如有TestCase：[-4,-4,2,2]。根据解题思路，在整个程序跑的过程中，会出现以下情况：1.当i=0,left=2,right=3时，得到结果[-4,2,2]，将其加入结果集；2.当i=1,left=2,right=2时，得到结果[-4,2,2]，不加入结果集。程序优化的目标就是使得情况2不要出现，因为情况2和情况1是一样的情况。对于每个i，如果array[i]==array[i-1]，那么可以跳过array[i]，因为它的情况和它的前一个数的情况相同。相应地left、right也可以做同样处理。 最终可以编写出如下的代码：1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Arrays.sort(nums); int length = nums.length; for (int i = 0; i &lt; length - 2; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; int left = i + 1; int right = length - 1; while (left &lt; right) &#123; int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(nums[i]); list.add(nums[left]); list.add(nums[right]); result.add(list); ++left; --right; while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) left++; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right--; &#125; else if (sum &lt; 0) &#123; ++left; &#125; else &#123; --right; &#125; &#125; &#125; Set set = new HashSet&lt;&gt;(result); result = new ArrayList&lt;List&lt;Integer&gt;&gt;(set); return result; &#125;&#125; 这个代码被AC了，但是运算速度排在18%左右。仔细想想，我们可以知道实际上对i、left、right进行处理后，情况2是不会出现的，其实也不需要去重了。所以可以对代码做进一步的优化，如下：1234567891011121314151617181920212223242526272829public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Arrays.sort(nums); int length = nums.length; for (int i = 0; i &lt; length - 2; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; int left = i + 1; int right = length - 1; while (left &lt; right) &#123; int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) &#123; result.add(Arrays.asList(nums[i], nums[left], nums[right])); ++left; --right; while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) left++; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right--; &#125; else if (sum &lt; 0) &#123; ++left; &#125; else &#123; --right; &#125; &#125; &#125; return result; &#125;&#125; 提交之后自然是AC了，运算速度排名在65%。 回过头来看我的那两个idea，真是太稚嫩了。nums在排序后，去重其实是很容易做到的，通过指针的移动即可完成，我却还试图费大功夫来实现一个效果不见得好的去重，而忽视排序所带来的便利，一叶障目，不见泰山。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java方法参数——值传递]]></title>
      <url>http://blade6.top/posts/c9c9e9c7/</url>
      <content type="text"><![CDATA[Java中的方法的参数是值传递还是引用传递争论已久，实际上取决于我们怎么定义这两个名词，但如果仅从定义层面去分辨，还是很难有比较好的效果。本文通过实例讲解。 基本数据类型这毫无疑问是值传递，换言之形参和实参互不影响。1234567891011public class Test1 &#123; public static void change(int a)&#123; a=50; &#125; public static void main(String[] args) &#123; int a=10; System.out.print(a + " "); change(a); System.out.print(a); &#125;&#125; 输出结果为：10 10 引用类型（数组、对象）注意形参实际上获得的是实参的一份拷贝，形参和实参都指向同一块内存地址。1234567891011public class Test &#123; public static void change(int []a)&#123; a[0]=50; &#125; public static void main(String[] args) &#123; int []a=&#123;10,20&#125;; System.out.print(a[0] + " "); change(a); System.out.print(a[0]); &#125;&#125; 输出结果为：10 50 String类String类实际上和引用类型一样，但又有一些不同。不同的地方在于String类的内容不可变，这就是String类之所以特殊的地方。123456789101112public class Test &#123; public static void change(String s2)&#123; s2="goodbye"; &#125; public static void main(String[] args) &#123; String s1=new String("hello"); System.out.print(s1 + " "); change(s1); System.out.print(s1); &#125;&#125; 输出结果为：hello hello当调用change()方法时，把s1的值（”hello”的内存地址）传递过去，s2的值将会和s1的值相同；当执行语句s2=”goodbye”时，将”goodbye”的内存地址赋给s2，此时s2的值和s1的值不再一致。所以s1的内容没有发生变化。P.S.而对于对象、数组，它们的数据域不一定是不可变对象，所以是可以通过使用形参改变的，于是出现了String类表现特殊的情况。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[金庸小说语录]]></title>
      <url>http://blade6.top/posts/17e47df0/</url>
      <content type="text"><![CDATA[神雕侠侣 黄药师笑道：“老顽童啊老顽童，你当真了不起。我黄老邪对‘名’淡泊，一灯大师视‘名’为虚幻，只有你，却心中空空荡荡，本来便不存‘名’之一念，可又比我们高出一筹了。东邪，西狂，南僧，北侠，中顽童，五绝之中，以你居首！” 天下养蜂之人，绝无风湿。 秋风清，秋月明；落叶聚还散，寒鸦栖复惊。相思相见知何日，此时此夜难为情。* 重剑无锋，大巧不工。 手中无剑,心中有剑,无剑胜有剑。 倚天屠龙记 世情推物理，人生贵适意，想人间造物搬兴废。吉藏凶，凶藏吉。富贵哪能长富贵？日盈昃，月满亏蚀。地下东南，天高西北，天地尚无完体。展放愁眉，休争闲气。今日容颜，老于昨日。古往今来，尽须如此，管他贤的愚的，贫的和富的。到头这一身，难逃那一日。受用了一朝，一朝便宜。百岁光阴，七十者稀。急急流年，滔滔逝水。 自来美人，若非温雅秀美，便属娇艳姿媚。 焚我残躯，熊熊圣火，生亦何欢，死亦何苦？为善除恶，唯光明故。喜乐悲愁，皆归尘土。怜我世人，忧患实多！怜我世人，忧患实多！ 武林至尊，宝刀屠龙。号令天下，莫敢不从。倚天不出，谁与争锋。 周芷若嫣然一笑，说道：“你们尽管做夫妻、生娃娃，过得十年八年，你心里就只会想着我，就只不舍得我，这就够了。” 这四个姑娘，个个对他曾铭心刻骨地相爱，他只记得别人的好处，别人的缺点过失他全都忘记了，于是，每个人都是很好很好的…… 周芷若冷笑道：“咱们从前曾有婚姻之约，我丈夫此刻却是命在垂危，加之今日我没伤你性命，旁人定然说我对你旧情犹存。若再邀你相助，天下英雄人人要骂我不知廉耻、水性杨花。”张无忌急道：“咱们只须问心无愧，旁人言语，理他作甚？”周芷若道：“倘若我问心有愧呢？ 生死修短，岂能强求？予恶乎知悦生之非惑邪？予恶乎知恶死之非弱丧而不知归者邪？予恶乎知夫死者不悔其始之予恶乎知蕲生乎？——《庄子》一个人寿命长短，是勉强不来的。我哪里知道，贪生并不是迷误？我哪里知道，人之怕死，并不是像幼年流落在外面不知回归故乡呢？我哪里知道，死了的人不会懊悔他从前求生呢？ 中国三千年的政治史，早就将结论明确地摆在那里。中国成功的政治领袖，第一个条件是“忍”，包括克制自己之忍、容人之忍以及对付敌人之忍。第二个条件是“决断明快”。第三是极强的权力欲。张无忌半个条件都没有。周芷若和赵敏却都有政治才能，但政治才能太强的姑娘，往往并不很可爱。我自己心中，最爱小昭。只可惜不能让她跟张无忌在一起，想起来常常有些惆怅。所以这部书中的爱情故事是不太美丽的，虽然，现实性可能更加强些。张无忌不是好领袖，但可以做我们的好朋友。事实上，这部书情感的重点不在男女之间的爱情，而是男子与男子间的情义，武当七侠兄弟般的感情，张三丰与张翠山之间、谢逊和张无忌之间父子般的挚爱。然而，张三丰见到张翠山自刎时的悲痛，谢逊听到张无忌死讯时的伤心，书中写得太也肤浅了，真实人生中不是这样的。因为那时候我还不明白。一九七七 三月——后记 天龙八部 《少年游》青衫磊落险峰行，玉壁月华明。马疾香幽，崖高人远，微步毂纹生。谁家子弟谁家院，无计悔多情。虎啸龙吟，换巢鸾凤，剑气碧烟横。 《苏幕遮》向来痴，从此醉，水榭听香，指点群豪戏。剧饮千杯男儿事，杏子林中，商略平生义。昔时因，今日意，胡汉恩仇，须倾英雄泪。虽万千人吾往矣，悄立雁门，绝壁无余字。 《破阵子》千里茫茫若梦，双眸粲粲如星。塞上牛羊空许约，烛畔鬓云有旧盟。莽苍踏雪行。赤手屠熊搏虎，金戈荡寇鏖兵。草木残生颅铸铁，虫豸凝寒掌作冰。挥洒缚豪英。 《洞仙歌》输赢成败，又争由人算！且自逍遥没谁管。奈天昏地暗，斗转星移。风骤紧，缥缈峰头云乱。红颜弹指老，刹那芳华。梦里真真语真幻。同一笑，到头万事俱空。糊涂醉，情长计短。解不了，名缰系嗔贪。却试问，几时把痴心断？ 《水龙吟》燕云十八飞骑，奔腾如虎风烟举。老魔小丑，岂堪一击，胜之不武。王霸雄图，血海深恨，尽归尘土。念枉求美眷，良缘安在？枯井底，污泥处。酒罢问君三语，为谁开，茶花满路？王孙落魄，怎生消得，杨枝玉露？敝屣荣华，浮云生死，此身何惧！教单于折箭，六军辟易，奋英雄怒！ 无人不冤，有情皆孽。 一切有为法，如梦幻泡影。如露亦如电，应作如是观。 碧血剑 这小姑娘荆钗布裙，装作乡姑时秀丽脱俗，清若水仙。这时华服珍饰，有若贵女，花荣至艳，玫瑰含露，袁承志心中砰的一跳，似是给内家高手击了一掌，忙转过了头，不敢多看。 二十岁不成国手，终身无望。 青青子衿，悠悠我心。纵我不往，子宁不嗣？青青子佩，悠悠我思。纵我不往，子宁不来？眺兮达兮，在城阙兮。一日不见，如三月兮？ 书剑恩仇录 《贺新郎．别茂嘉十二弟》 辛弃疾绿树听鹈鴃。更那堪，鹧鸪声住，杜鹃声切。啼到春归无寻处，苦恨芳菲都歇；算未抵人间离别。马上琵琶关室黑，更长门翠辇辞金阙；看燕燕，送归妾。将军百战身名裂，向河梁，回头万里，故人长绝；易水萧萧西风冷，满座衣冠似雪，正壮士悲歌未彻。啼鸟还知如许恨，料不啼清泪长啼血。谁共我，醉明月。 文无第一，武无第二。 善攻者攻敌之必守。 情深不寿，强极必辱。谦谦君子，温润如玉。 浩浩愁，茫茫劫。短歌终，明月缺。郁郁佳城，中有碧血。碧也有时尽，血亦有时灭，一缕香魂无断绝。是耶？非耶？化为蝴蝶。 诸行无常，诸法无我。人之所滞，在以无为有。若托心本无，异想便息。 华灯看罢移香屧。正御陌，游尘绝。素裳粉袂玉为容，人月都无分别。丹楼云淡，金门霜冷，纤手摩挲怯。三桥婉转凌波蹑。敛翠黛，低回说。年年长向凤城游，曾望蕊珠宫阙。星桥云灿，火城日近，踏遍天街月。 飞狐外传 程灵素微微一笑，低声问道：“大哥，待会如果走不脱，你救我呢，还是救马姑娘？”胡斐道：“两个都救。”程灵素道：“我是问你，倘若只能救出一个，另一个非死不可，你便救谁？”胡斐微一沉吟，说道：“我救马姑娘！我跟你同死。” 俗话说得好：“文无第一，武无第二。”凡是文人，从没一个自以为文章诗词天下第一，但学武之士，除了修养特深的高手之外，决不肯甘居人后。 儒以文乱法，侠以武犯禁。 笑傲江湖 行乎其不得不行，止乎其不得不止。 神凝丹田，息游紫府，身若凌虚而超华岳，气如冲霄而撼北辰。 是非只为多开口，烦恼皆因强出头。 瓦罐不离井上破，将军难免阵上亡。 欲除烦恼须无我，各有姻缘莫羡人。 彼亦不敢先，此亦不敢先，惟其不敢先，是以无所争；惟其无所争，故能入于不死不生。P.S.指下棋中的双活 朝闻道，夕死可矣。 鹿鼎记 平生不识陈近南，就称英雄也枉然。 绝世奇事传闻里，最好交情见面初。P.S.“最好交情见面初”是一见如故的意思，并不是说初见面交情最好，后来就渐渐不好 偏偏茅大哥骨头硬，不肯冒充。但骨头硬，皮肉就得受苦了。常言道得好：‘好汉不吃眼前亏’，吃眼前亏的自然不是好汉。 居移气，养移体。 天下的道路永远行走不完，就算走完了，老路再走几遍又何妨？P.S.好情话！ 花无常开，月有盈缺，世事原不能尽如人意。 有心皆苦，无心即乐。 生命中永远有特殊的意外。——后记 遇到初会的读者时，最经常碰到的一个问题是：“你最喜欢自己哪一部小说？”这个问题很难答复，所以常常不答。单就“自己喜欢”而论，我比较喜欢感情较强烈的几部：《神雕侠侣》、《倚天屠龙记》、《飞狐外传》、《笑傲江湖》、《天龙八部》。又常有人问：“你以为自己哪一部小说最好？”这是问技巧与价值。我相信自己在写作过程中有所进步：长篇比中篇短篇好些，后期的比前期的好些。不过许多读者并不同意。我很喜欢他们的不同意。——后记 白马啸清风 那些都是很好很好的，可是我偏偏不喜欢。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Longest Palindromic Substring]]></title>
      <url>http://blade6.top/posts/8872b998/</url>
      <content type="text"><![CDATA[问题：给定字符串s，求出其最长回文子串。方法一：动态规划。思想描述：假设 s[i][j] 表示字符串 s 下标从 i 到 j 的子串，如果该子串是回文子串，则令 dp[i][j] 为 true 。如果我们已经得到了最优解，这个最优解是 s[i][j] ，无疑 dp[i][j] = true 。而 dp[i][j]=true 实际上等价于 dp[i+1][j-1] = true &amp;&amp; s[i] == s[j] ，这就是推导式。考虑 i+1 == j-1 ， i+1 == (j-1)-1 ，分别对应回文子串长度为1和为2的情况，这就是基准情况：a. dp[i][i] = trueb. dp[i][i+1] = true if s[i] == s[i+1] 代码如下：12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; //Dynamic Programming public String longestPalindrome(String s) &#123; if(s.length()==0 || s.length() == 1) return s; int length = s.length(); int max = 1; String result = "" +s.charAt(0); boolean[][] dp = new boolean[length][length]; for(int i=0;i&lt;length;i++) dp[i][i] = true; for(int i=0;i&lt;length-1;i++)&#123; if(s.charAt(i) == s.charAt(i+1))&#123; dp[i][i+1] = true; if(max != 2)&#123; max = 2; result = s.substring(i, i+2); &#125; &#125; &#125; for(int i = length - 3; i &gt;= 0; i--)&#123; for(int j = i+2; j &lt; length; j++)&#123; if(dp[i+1][j-1] &amp;&amp; s.charAt(i) == s.charAt(j))&#123; dp[i][j] = true; if(j-i+1 &gt; max)&#123; max = j-i+1; result = s.substring(i, j+1); &#125; &#125;else&#123; dp[i][j] = false; &#125; &#125; &#125; return result; &#125; &#125; 需要注意的地方：实现动态规划时，需要注意边界，从哪里开始，到哪里结束。 方法二：中心扩展。思想描述：回文串是中心对称的，以 s[i] 为中心，用两个指针向两侧扩展判断是否相等可以得到以s[i]为中心的回文子串，对s的每个字符重复此操作，最终可以求得最大回文子串。 代码如下：123456789101112131415161718192021222324252627282930public class Solution &#123; public String longestPalindrome(String s)&#123; if(s.length() == 1 || s.length() == 0) return s; int max = 1; int ans; String result = "" +s.charAt(0); for(int i=1;i&lt;s.length();i++)&#123; ans = Math.max(PS_length(s, i-1, i+1), PS_length(s, i-1, i)); if(ans &gt; max)&#123; max = ans; if(ans % 2 == 0) result = s.substring(i-ans/2, i+ans/2); else result = s.substring(i-ans/2, i+ans/2+1); &#125; &#125; return result; &#125; //PS is short for Palindromic Substring public int PS_length(String s, int i, int j)&#123; while(i &gt;=0 &amp;&amp; j &lt; s.length())&#123; if(s.charAt(i)!=s.charAt(j)) break; --i; ++j; &#125; return j-i-1; //return (j-i-1)+2 &#125; &#125; 小trick：在求子串时，下标可以通过实例来明确。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[回车符与换行符]]></title>
      <url>http://blade6.top/posts/285ba2a7/</url>
      <content type="text"><![CDATA[昨天晚上做NLP的时候，需要对文件做一些预处理。然后无意中发现一点小问题。通过用python和java分别对文件进行输出文本行数，发现不同。输入文本文件:199801.txt下面是Java实现的代码：12345678910111213141516171819202122232425import java.io.*;import java.util.*;public class test &#123; public static void main(String[] args) throws FileNotFoundException &#123; java.io.File in_file = new java.io.File("199801.txt"); Scanner input = new Scanner(in_file); java.io.File out_file = new java.io.File("test.txt"); java.io.PrintWriter output = new java.io.PrintWriter(out_file); //p_num表示文本总行数，q_num表示存在有效文字的行数 int p_num = 0,q_num = 0; while(input.hasNextLine())&#123; String line = input.nextLine(); ++p_num; if("".equals(line))&#123; continue; &#125; ++q_num; output.println(q_num+" "+line); &#125; System.out.println(p_num+" "+q_num); input.close(); output.close(); System.out.println("Done!"); &#125;&#125; 控制台上输出：23064 19484Done!用Python实现的情况如下：1234567891011121314151617181920f = open('199801.txt','r')g = open('test1.txt','w')p_num = 0q_num = 0while True: line = f.readline() if len(line): p_num += 1 if line != '\n': continue q_num += 1 g.write(str(q_num)+" "+line) else: breakf.close()g.close()print p_num,q_num 控制台输出：22722 19538 可以观察到总行数Java这边较大，有效行数Python这边较大。我决定首先解决有效行数不一致的问题。因为我在代码中还写了把有效行写成文件的内容，所以我决定检查一下test.txt和text1.txt文件有什么不同。手动打开两个文件，通过粗略估计+二分搜索法，确定第一次输出不同在第341行。(P.S.有效行是指该行中存在文字。)text.txt line341: 341 19980101-07-007-001/m 细语/n （/w 中国画/n ）/w tex1.txt line341: 341 也就是text1.txt的341行实际上不是有效行，说明Python代码中判断是否是有效行的逻辑有错误。于是我认为输入的文本文件中可能混有回车符和换行符。（P.S.这里考虑到文章的整体的流畅性，省略了很多细节。实际上最初我认为问题出在Java，因为我引入了C++语言，统计文本行数的结果和Python是一致的。当时我认为问题出在Java代码中的input.nextLine()处，所以搜索了很多关于这个函数返回值的问题，知道了nextLine()会吞掉换行符。然后通过百度换行符，我又了解到了回车符这个概念，其实以前学过，忘记了。。）于是我对Python代码稍加修改，增加在原代码13行和14行之间:1234if q_num == 341: print len(line) if line == '\r\n': print 'bingo' 控制台显示： 2bingo22722 19538 于是判断出问题的关键在于’\r’和’\n’。于是我对Python代码进行了再次修改：1234567891011121314151617181920f = open('199801.txt','r')g = open('test1.txt','w')p_num = 0q_num = 0while True: line = f.readline() if len(line): p_num += 1 if line == '\n' or line == '\r\n' or line == '\r': continue q_num += 1 g.write(str(q_num)+" "+line) else: breakf.close()g.close()print p_num,q_num 再执行了一遍，控制台输出： 22722 19485 为什么有效行数仍然多了一行？首先需要找出有问题的行，于是我写了一段Python代码，避免手工排查：（P.S.其实第一次手工排查前我就尝试写脚本排查，无奈因为不知道回车符，导致没有写出有效的脚本）123456789101112131415161718192021f = open('test1.txt','r')g = open('D:\\java\\Dev\\test.txt','r')num = 0while True: line1 = f.readline() line2 = g.readline() num += 1 if line1 != line2: if len(line1) == len(line2)+1: continue else: break if not len(line1): breakprint num,len(line1),len(line2)f.close()g.close() 因为text1.txt有些行有\r，所以有些行的长度会比text.txt中的对应行大1，但实际上有效内容是一致的，所以代码中进行了忽略这样的行。执行后控制台输出： 1265 8 77 可以看到两个文件是在第1265行出现分歧的。有了之前的经验教训，我怀疑text1.txt的1265行的内容是”1265 \r\r\n”，通过对脚本的代码稍加修改：12345678910111213141516171819202122232425f = open('test1.txt','r')g = open('D:\\java\\Dev\\test.txt','r')num = 0while True: line1 = f.readline() line2 = g.readline() num += 1 if line1 != line2: if len(line1) == len(line2)+1: continue else: if num == 1265: print len(line1) if line1 == "1265 \r\r\n": print 'bingo' break if not len(line1): breakprint num,len(line1),len(line2)f.close()g.close() 控制台输出： 8bingo1265 8 77 证明我的判断是正确的。至此，解决了有效行数不一致的问题。那么为什么总行数会不相等呢？实际上，Python中f.readline()返回一行，不对这行做任何处理。而Java中input.nextLine()会获取从当前位置开始到一个结束符前的内容，然后去掉末尾的结束符返回。通过对本文Java代码稍加改写，可以发现’\r’，’\n’都会被认为是结束符。比如：当文本中有一行的内容为”\r\n”时，f.readline()会返回”\r\n”，行数加1。input.nextLine()返回”\r”前的内容，也就是””，行数加1；然后input.nextLine()会返回”\n”前的内容，也是””，行数加1。读取这一行后，Java和Python的行数就出现不一致了。 综上，对于Java中的Scanner的nextLine()方法，其名字中的nextline并不是真正意义上的下一行，准确地说应该是从当前位置到下一个结束符之前的内容。Python的readline()方法返回真正意义上的一行，所以在对行做处理时，需要考虑行末是换行符或回车+换行符的情况。 附上回车符与换行符的区别： CR：CarriageReturn，回车符，用’\r’表示，16进制代码为0x0D，光标移动到当前行的最左边。LF：LineFeed，换行符，用’\n’表示，16进制代码为0x0A，把光标向下移动一行。 不同操作系统表示一行的结束不同：Unix、Linux：\n表示回车+换行，\r无意义Windows、DOS：\r\n表示回车+换行，顺序不能颠倒Mac：\r表示回车+换行(P.S.Mac OS 9以及之前的系统的换行符是CR，从Mac OS X（后来改名为OS X）开始的换行符是LF，和Unix/Linux统一了。) 影响：（1）一个直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；（2）而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。（3）Linux保存的文件在windows上用记事本看的话会出现黑点。 相互转换：在linux下，命令unix2dos 是把linux文件格式转换成windows文件格式，命令dos2unix 是把windows格式转换成linux文件格式。 在不同平台间使用FTP软件传送文件时, 在ascii文本模式传输模式下, 一些FTP客户端程序会自动对换行格式进行转换. 经过这种传输的文件字节数可能会发生变化.如果你不想ftp修改原文件, 可以使用bin模式(二进制模式)传输文本。一个程序在windows上运行就生成CR/LF换行格式的文本文件，而在Linux上运行就生成LF格式换行的文本文件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2016年总结]]></title>
      <url>http://blade6.top/posts/e441dee4/</url>
      <content type="text"><![CDATA[眨眼又是一年，这一年发生了很多事情，其实每年都有很多事情发生，但是今年我更有感触。这一年我从大二升到大三，从20岁走向21岁，看淡了一些事，看破了一些事，虽然身上依然有很多顽劣，但总的来说是有成长的。养成总结的习惯并不是一件坏事，活的时间越长，经历越多，忘记的也会越多，记在文字里不失为一种途径。 1-2月学车今年年初比较早放寒假，好像是11号吧，而且寒假很长，有四十天左右。放寒假我就回家了，教练催我去考科目一。过了科目一之后练了几天车，过年的时候休息了十几天，之后又练了几天就滚回学校了。因为科目二排队的人很多，所以我也没想着寒假能把科目一和二过了。练车印象最深的就是科二的教练很严格，在他的呵斥下我总是过于紧张，尽管他的本意是把马路司机扼杀在摇篮里。为了学车还查了很多资料，做了很多思考，虽然有很多时候都是想得太多，做的太少，不过练车机会少，只能自己意淫了。练车期间还认识了一个大五的师兄，因为师兄读的是建筑专业，所以是五年本科。大五师兄给我的感触就是很多他以前同学都已经工作半年了，给了他很多同辈压力（peer presure），所以他常常感叹工作、钱、未来这些事情。不知道为什么，我和他聊天很有感觉。我想等到我毕业的时候我也会是这样吗？我会的，这些都是很现实的东西，没有人能够脱离现实谈理想。 学习这段时间里因为网络安全小组有作业，就是自己搭建一个博客网站。幸好在这之前我已经找师兄要了网站建设的课件，所以寒假里也花了差不多半个月的时间自学html,css,php,js。寒假时候的我有很深的忧虑感，都已经大二上学期了，依然感觉自己在专业上一无所长。搞技术的日子基本上就是产生问题、解决问题的过程，最后的成果很简单，但是学到的php知识在下学期的数据库大作业用上了，也算是歪打正着了。 读书寒假里看了两本书吧，《白夜行》和《笑傲江湖》。当时的我很贪心，书单列得很长，书单的增长速度远大于我的阅读速度。现在的我把当时的书单删除了很多，没必要逼得自己喘不过气。我觉得一个人读什么书是命运使然，所以如果我读少一本，我不会觉得是一种损失。但读多一本，我说不定就赚了。《白夜行》看完之后是有些失望的，我原先以为是一部侦探小说，看的时候对很多细节都很留心，结果白费心机。《笑傲江湖》我很喜欢，是一本很棒的书，在我心目中，金庸小说排名榜第三。从15年2月看《天龙八部》开始养成看书的习惯，到16年4月看完《鹿鼎记》，金庸小说我看了一年零两个月。对我来说，小时候看电视剧基本都是断断续续地，没有完整看完。仔细想想，真正看完的电视剧其实情节我也不记得了，而虽然电视上经常播金庸武侠剧，也许是命吧，我好多次看到的都是同一个情节，比如《神雕侠侣》，好多次我转台都是绝情谷的情节和全真教的情节，我从来没有看过活死人墓的情节，所以有很多情节我都不知道，看书的时候完全没有被剧透的感觉，这一点真棒。以后有时间写写金庸小说的总结吧。 看剧寒假里还看了几部电影，看了《生活大爆炸》前几季和补了《仙剑奇侠传》第一部。印象比较深的是《仙剑》。这部2006年的电视剧拍得真棒，其实这部剧我很早就想去补了，我第一次看是在高一的时候，湖南卫视暑期档播放的，那个时候看了之后超喜欢，虽然是断断续续看的。我不记得那个时候是什么原因才没有在电脑上补完，难道是沉迷游戏？真的忘了。《仙剑》中有人、仙、妖，每个人都有他做这件事的理由。看完之后我最大的感觉就是世界上根本就没有恶，每个人都是为了自己心中的善，纷争不过是善与善的冲突。这让我想起了路西法效应： 有一个问题是，当津巴多说“好人”变成了“坏人”时，那些“坏人”并不认为自己成了坏人，他们要么认为受害者罪有应得，要么认为自己只是采用了恶的手段来实现其正当的目的，用目的的合理性为自己采取的手段辩护——虐囚的士兵是为了获取反恐所需的情报，恐怖分子是为了民族解放，在他们的同仁眼里他们也是道德英雄。这根本上是不同的善之间的冲突，而不是善和恶之间的冲突，已经超出了心理学的范畴。 3-6月流水账3月发生的事情我已经没有什么印象了。当生活一成不变的时候，一个月和一天其实并没有什么区别。这段时间里主要做的就是学习吧。有个培训好像也是这段期间参加的，学了一些Android的基本知识。4月我喜欢上了算法这门课，每天有时间就上学校的OJ去做题，重拾了一些C++编程的基础，也从实践中明白算法是需要天赋的，就像奥数的那种天赋。付出一些努力，我侥幸地在五月的算法小测做出了四道题，虽然题目其实并不难。而五月，才是梦魇的开始。在五月里，我一方面被学院党建各种折磨，另一方面又需要完成好几科的大作业。让人寒心的就是明明是小组作业，但大家表现得不关自己事一样。这让我想起了电影《超脱》中一句台词： It’s so easy to be careless,it takes courage and courage to care. 庆幸的是我熬过了。仔细想想，组队的时候真的应该仔细斟酌，不能为了组队而组队。自己没找好队友，抱怨也没有用。6月基本都在忙期末复习，也忙里偷闲看了好多电影。 朋友圈和跑步从五月的下旬开始，我开始关闭朋友圈和跑步。这一关就是3个多月，直到9月初才开始恢复使用。关闭朋友圈的原因已经不重要了，无非是常常打开做一些无意义的刷新，虽然现在还是会有。朋友圈的模式我都总结出来了，大致是琐碎、吐槽、段子、帮转、虐狗、自拍、代购。其实看得多了都厌了。跑步是因为那段时间每天晚上都很难入睡，很多负能量，于是通过运动来作为一种宣泄，把自己累得没有时间去想。当我在跑步的时候，我会去关注呼吸、身体、周围环境，这样能使我从精神上的痛苦中抽离出来。 租车网数据库大作业做了一个租车网站，因为队友突发奇想冒出这个想法，于是就做了。因为之前做过博客网站，所以我对这个网站的构建比较有想法，先设计数据库，再做网站。但由于经验的匮乏，考虑了太多细枝末节的东西，经历了多次的修改。在很多方面有很多的不足，也有很多功能没有实现，有很多功能最终简单化处理。总的来说，花了很多功夫，做的差强人意。展示那天，很多同学的作品都很不错，感觉自己还有很大距离。展示当天也发生了一些不愉快，花了我好长时间才释怀。 7-8月这个暑假很漫长，足有72天，甚至超过了我小学时候的暑假长度，我只想对学校说：退钱！开玩笑哈。其实这两个月我总的来说就是做了三件事，第一件就是自学Android，第二件就是练车，第三件就是浪费时间。 自学Android放暑假的前14天我都没有回家，而是待在学校。因为关注了微信公众号AndroidDeveloper，而且参加了一次Android的培训，对Android有一定的了解，又感到自己没有什么技能拿得出手，于是决定进行学习，虽然总共只学习了十几天时间。看的书就是《第一行代码》，把上面的代码都实现了一下，感觉还是学到了不少。虽然现在已经忘了很多，不过曾经学过的话，重拾起来也比较快。学的时候就是每天强迫自己看五十页，并实现相关代码。这次学习最大的收获就是接触到GitHub。GitHub上还有我当时做的CoolWeather项目，因为一些原因还没有实现相关功能，有时间我再研究一下。虽然只是短短的十几天，但是白天调bug调的心累，晚上又失眠，我记得最严重的一次是一直头疼，无法入睡，后来受不了了下床吃了清热解毒的药，发现已经三点五十几分了。所以用度日如年来形容并不为过。现在我不会逼自己这么紧了，万一猝死了，打怪练的级别再高也没用了。而且我觉得这样做太过于消耗学习的热情了，会打击人的积极性，得不偿失。 科目二具体过程也不必多说了。很多东西，没有尝试过，就不知道。多一种经历，多一点智慧。 作者：Blade6链接：https://www.zhihu.com/question/24518251/answer/113078508来源：知乎著作权归作者所有，转载请联系作者获得授权。今天过了科二，来回答这个问题攒个人品。我是在考前几天看到这个问题的，在这么多个答案里面 @Liekkas 答案的最后一段话最触动我，谢谢你。考试的时候要保持平常心，相信自己的实力，即使不太稳定，考试的时候指不定运气好呢。我考第一遍的时候，在s弯挂了，听着车里提示音报着“不合格”，我有一瞬想到出考场后的很多事情。第二遍的时候我再次到s弯的时候我把车速压到最低，然后缓缓地进，缓缓地打方向盘，第二遍过了。其实我第一遍就可以过了，就是在s弯大意了。因为我们这里的顺序是s弯是第四项，而我的弱项是倒车入库，我在前面的项目完成之后大意了，结果挂在后面的简单的项目。第一遍死掉之后我真怕第二遍在第一项倒车入库就挂了。第二遍倒车入库过了之后整个人又找回了些信心，每一项都把车速压慢，动作做好，注意细节。然后考试合格。我个人其实不太推崇早打方向盘的做法，最好就是每个点都看准，方向盘都打好，的确，倒车入库，早打方向盘可以早回方向盘来救，但是这样养成的习惯不好，平时练车就把点看准来，与其学习各种补救的方法，不如在一开始的时候就避免这个问题的出现。不过，补救的意识要有，有时候打的时机会差一点点，这个时候补救是救得回来的，千万不要过早放弃。最后，在考场的等待是最煎熬的。我从最开始的不紧张等到紧张，再从紧张等到不紧张。在考场的时候要有意识地平静自己的心态，紧张的时候就深呼吸，不要过多地受那些考完试的人的影响。在考试的时候，车里就你一个人，慢慢开，可以在白线区域里面停一会儿，想想下一个项目的操作，然后再开进黄线区域去继续考试。两次机会，过就过，不过就说明还有不熟练的项目，回去练熟之后再考过。科目二说难不难，说易也不太易。要对自己有信心，即使对自己的实力没信心，也要对自己的运气有信心，那些平时练车各种问题考试一把过的案例我听过的都有两三个。上午考的试，下午码着这个答案的时候还觉得像做梦一样。人生啊~ 浪费时间整个暑假我做的最多的事情就是浪费时间了。我花了大部分时间看完了《奔跑吧兄弟》全四季，也看了《Running Man》的一部分。我还看了《我和僵尸有个约会》前两部。我还很努力地把《摩登家庭》追完前七季。我也花了很多时间玩杀人游戏、谁是卧底，研究狼人杀。也看了很多电影，一本书都没有看（除了上文提及的《第一行代码》）。我还天天晚上看B站的直播。可能是这个学期过得太艰辛，所以心中有很多苦，也没处诉说，只好用各种娱乐麻痹自己。虽然浪费了很多时间，不过自己也看的开了，时间的确是被浪费了，但是也必要觉得自责，负面情绪终归是需要发泄的，不管是一瞬间的爆发，还是在麻痹里一点点流逝。而且暑假也想了很多，明白了自己的路，很多以前纠结的事情突然开朗了，塞翁失马焉知非福。 9-12月9月基本上仍处在暑假的状态，课余时间都在看剧和电影中度过了，课堂作业还是会认真完成的。因为明白了活在当下的意义，所以在生活中也不再想去省钱减轻父母负担什么的，只想活好自己的人生。10月前半段基本和9月相似，这段时期有个特点就是当你只顾着去娱乐自己的时候，就会陷入无聊空虚的状态。大概是10月中下旬起，感觉实在是太无聊了，于是开始找些事情干。发现现在很多人用GitHub Pages+Nodejs+Hexo搭建博客，于是我也搭建了一个。苦于知识储备量少，博客网站空空如也。 11月前半段基本在忙数据库工程大作业，使用thinkphp对原来的租车网进行了很多修改。打代码的时候可以说是废寝忘食，脑子里也不用去想别的事情，只专注于每一行代码，实在是莫大的幸福。后半段就没那么好过了，晚上终点失眠，十二点多才睡，五点多醒了。。我正常的生物钟要睡到九点的。差不多每天都这样。经过了好多天的折腾，心态也较缓和了。少睡一点也不见得会怎样。心态好了虽然还是会有醒来的情况，但是第二段睡眠的入睡没那么困难了。11月还看了古龙的《多情剑客无情剑》，很棒的小说，和金庸的不同的是，古龙描写环境氛围，杂着议论，就能让读者爽了，真大师也。其实这个学期也看了韩寒的书《1988我想和这个世界谈谈》，太宰治《人间失格》等。11月的后半段迷上了一个80年代末90年代初的香港谈话节目《今夜不设防》，很棒的一个节目，感觉学到了很多东西，虽然我也说不出来是什么。。 11月末12月上半段发生了一些事，人人自危。不过过了十几天后，一切又回归正轨了。12月忙着弄大作业了，先是图像处理的大作业，然后是数据库大作业，又作了一些修改，然后是数据挖掘的大作业，直到做prezentation的前一天才找到思路。2016年的最后几天，都在忙大作业了。忙的时候，也没空去想别的，生活变得简单。 一转眼，就走到了2016年的最后一天，2016对于我来说，是一份礼物，我很感激。这个自媒体繁荣的时代，我能轻易获取我想要的信息和内容，这是一件好事。虽然说门槛变低，有点经验都能出来卖，增加了我的筛选成本。但我这一年还是从别人的分享中学到了很多，能够用一种更客观更宽容的态度看待很多东西。就用一句杜甫的诗句结束吧： 莫思身外无穷事，且尽生前有限杯。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[往事如烟]]></title>
      <url>http://blade6.top/posts/c8eb575c/</url>
      <content type="text"><![CDATA[《今夜不设防》剧评起因一开始我是看了《笑林广记》这本书，然后对黄色笑话产生兴趣进而了解到黄霑先生写过《不文集》，看完《不文集》之后觉得不过瘾，百度香港四大才子，发现其中三个又被称为香港三大名嘴，原因很大程度是因为一档《今夜不设防》的娱乐节目。这档节目真的可以说是充分体现了香港社会的高度自由，节目中主持人可以抽烟喝酒，大谈性事，而且三位主持人都是学识渊博之人，使你在观看之余常常拍案叫绝，叹为观止。黄霑和蔡澜主持这档节目时49岁左右，倪匡56岁左右（注意：百度百科上说倪匡的出生年份是1938年，不准确。在林建明、吴君如、邱淑贞当嘉宾那期，倪匡亲口说自己1935年出生）。三个男人的搭档使我联想到《奇葩说》，2015年的时候，马东47岁左右，高晓松46岁左右，蔡康永53岁左右。是不是要活到天命之年，才能把人与事看得这么通透？ 星光璀璨这档节目请了很多当时的明星上来，这些明星在当时自然很红，今时今日已然成为了传说。包括张国荣、罗大佑、周润发、成龙、林青霞、吴宇森、曾志伟等等。我一直相信人生中的很多事情相互之间都是有关联的，这个节目虽然很大程度上聊的都是八卦，但是言谈之中有些理念在一定程度上未尝没有可取之处。 许冠文许冠文那期，可以了解到在周星驰时代之前的另一个无厘头时代。许冠文就像一本书，看上去很严肃死板的样子，实际上里面幽默极了。而且他喜欢用一种夸张的方式来传达他要说的东西。 周润发周润发那期，可以看见这位影坛老大哥豁达的心态，在不同的时期都有很不错的作品交出来，而且在节目中他对付三位才子游刃有余，把节目当做了自己的主场。七十年代有《上海滩》，八十年代有《英雄本色》小马哥、《赌神》，九十年代有《卧虎藏龙》，这样的成绩已经独孤求败了。虽然现在在拍些捞钱的商业片23333 麦嘉麦嘉那期，可以了解到一个大哥的不容易，而且麦嘉看上去笑嘻嘻弥勒佛一样，其实是个非常聪明而且很有胆色的硬汉，后来更是笃信密宗。在节目中他说佛教是骗人向善，这个说法真的是一语点破我心中的困惑。我一直很好奇佛教很多的宣传都是什么功德，不是说色即是空吗？麦嘉这期我非常喜欢，麦嘉这个阅历丰富的老油条，和三位主持人过招的时候，使我明白了人和人的交往是有层次的，当交流的个体有足够的智慧时，在交流上也会更圆滑更睿智，这一期就像看华山之巅的几个高手过招一样。 三位主持三位主持人的观念一方面很前卫，比如他们支持多元的婚姻关系，就是在婚姻之外，还可以建立别的情侣关系。这样的观点即使在二十六年后的今天也是相当前卫，也许未来会实现。我个人其实也不反对这样的婚姻关系，但是这样的关系毫无疑问将诞生于法律制度相当完善、人们观念相当开明的时候，而这样的时候可能还有很久很久。另一方面也带有浓厚的个人色彩，换言之不具有普适性，一个人的观念不仅仅反映他的年龄，也反映他的地位和阅历。 蔡澜节目中可以看到三位主持人都是真性情之人，我冲着黄霑而来，发现更喜欢蔡澜。蔡澜先生在节目中可以看出说话比较慢，常常都是话还没说完，别人就明白他的意思了，这一点很有意思，一定程度上我可以说蔡澜精于留白这种智慧。而且他经常主动聊起性事，聊起来的时候，还一本正经，仿佛讨论的不是一件不能见人的事情。是啊，性本来就没有什么神秘的。蔡澜先生对《三只老虎》这首歌情有独钟，不知道是不是过了10多年版本变了，怎么我小时候听到的是《两只老虎》版本？更有意思的是蔡澜先生的人生观，追女孩子就要勇于尝试，要去问，问有50%的机会，不问就是0。问了失败，就直接转向下一个。这个恋爱观真是十分的豁达，虽然会显得用情不深。但是我们活在人世间，为什么总幻想自己会有这样的好运能在爱情这件事上得偿所愿？ 黄霑黄霑差不多每个女明星都亲一口，真的是羡慕死观众了。在节目中可以看出黄霑常常咳嗽，想必是烟抽多了，后来的肺癌也印证了。但是黄老邪很豁达，写的词充满了豪气。我发现很多喜欢的歌的歌词都出自他之手。有时候我会觉得才学如此高的人，没有去研究学术是不是一种浪费，但其实人生短短数十载，如果不去做自己喜欢的事情难道不是一种更大的浪费？黄霑在生命的最后几年还攻读博士学位，他的毕业论文研究香港音乐的发展史，从中可以窥见他对香港的深情。 倪匡倪匡先生在节目中经常打断别人说话，有时候会让人觉得很烦，但是这个节目叫做今夜不设防，不能掩饰自己，他实际上很符合这个主旨。话虽这么说，看叶童那期，他和黄霑在那里争，看到我都替叶童尴尬，最后实在不得已放弃观看。倪匡声称自己是港台五酒鬼之一，这个港台五酒鬼中还包括古龙。可惜古龙那时候已经去世了，如果可以看到他就好了。倪匡喜欢拿朋友家的东西，看到喜欢就拿，做事情非常自我，也可以说他活得不用看任何人的脸色，完全凭个人喜好。 往事如烟看这个节目会让我产生一个错觉，仿佛他们不是身处二十六年前，而就在我活着的这一刻。而实际上当我听到节目中的每一个名字，百度搜索之后都会发现岁月的痕迹。很多节目中风华正茂的人，今日早已变成历史。这档二十六年前的节目，就像是一个窗口，让我能够透过这个窗口，看见一个时代，看见那些人，那些事。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Hexo搭建个人博客小记]]></title>
      <url>http://blade6.top/posts/21637/</url>
      <content type="text"><![CDATA[今天购买了域名，基本上完成了博客的各项配置，接下来就可以开始写博客了。因为目前暂时没有什么干货，只好把建站的一些过程发上来撑撑场面，~_~ 动机其实在今年年初的时候，师兄就让我们搭建自己的博客。那个时候的我，完全0基础。硬是一个寒假在虚拟机上搭建了一个博客，那个时候只是把它当成作业来完成的，做得十分简陋，这里就不po上来献丑了。做好之后就搁置了。直到这个学期，前几周，计算机英语老师说计算机专业的学生怎么能没有自己的个人网站，于是我萌生了搭建博客网站的想法。因为现在Nodejs+Hexo+Github Pages搭建博客很流行，于是我也加入了这股潮流。说干就干，网上的资料十分多，可能是每个搭建博客的都写了一篇建站日志, : ) 建站大致过程 安装Git Bash,Nodejs,Hexo. GitHub新建repo，并设置SSH. 下载安装next主题，并按照NexT的内容进行各项参数的设置。 多说评论、分享、热评文章 LeanCloud阅读次数统计 Local Search 购买域名。 SEO推广 文章链接唯一永久化 更改阅读全文样式打开\themes\next\source\css\_common\components\post\post-button.styl文件，修改成1234567891011121314151617181920212223242526.post-button &#123; margin-top: 50px; .btn &#123; display: inline-block; border-width: 2px; border-style: solid; border-color: rgb(85,85,85); padding: 0 20px; line-height: 2; font-size: 14px; color: #555555; text-decoration: none; &#125; .btn:hover &#123; color: white; background-color: #222222; &#125;&#125; 参考资料如何使用10个小时搭建出个人域名而又Geek的独立博客使用Hexo搭建个人博客(基于hexo3.0)Hexo系列教程Hexo+nexT主题搭建个人博客使用Hexo搭建博客的深度优化将hexo博客同时托管到github和codinghexo提交搜索引擎 在此致谢所有无形中帮助到我的人，谢谢你们的分享。互联网精神万岁！]]></content>
    </entry>

    
  
  
</search>
