<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Java的static关键字]]></title>
      <url>http://blade6.top/posts/584c0905/</url>
      <content type="text"><![CDATA[通常，在一个类中定义一个方法为static，那就是说，无需本类的对象即可调用此方法，关于static方法，声明为static的方法有以下几条限制： 它们仅能调用其他的static方法。 它们只能访问static数据。 它们不能以任何方式引用this或super。 无论是static修饰的变量，还是static修饰的方法，我们都知道他们是属于类本身的，不是属于某一个对象的，当声明一个对象时，并不产生static变量和方法的拷贝。也就是说，用static修饰的变量和方法在类加载的时候，只分配一块存储空间，所有此类的对象都可以操控此块存储空间。 当子类没有与之同名的static变量（或方法时），子类的对象也可以操控这块内存空间。但是子类并没有继承父类中static修饰的变量和方法。因为static修饰的变量和方法是属于父类本身的。 12345678910111213141516class T &#123; public static int i = 3;&#125;public class Test extends T &#123; public static int i = 5; public static void main(String[] args) &#123; System.out.println(Test.i); ++Test.i; System.out.println(Test.i); System.out.println(T.i); &#125;&#125; 输出结果为5 6 3如果把第7行去掉，输出结果为3 4 4这说明子类的确没有继承父类的static字段，因为如果是继承的话，子类和父类的应该是区分的，而不会出现T.i和Test.i访问的是同一个字段的情况。 静态方法不能被覆盖，但如果子类重新实现的话，会被隐藏，需要使用父类名.方法名来访问。 1234567891011121314151617181920212223242526272829class T &#123; public static void A() &#123; System.out.println("T.A"); &#125; public static void B() &#123; System.out.println("T.B"); &#125;&#125;public class Test extends T &#123; public static void B() &#123; System.out.println("Test.B"); &#125; public static void main(String[] args) &#123; Test.A(); // 访问父类方法 Test.B(); // 访问类方法 T t1 = new Test(); t1.A(); // 访问父类方法 t1.B(); // 访问父类方法 Test t2 = new Test(); t2.A(); // 访问父类方法 t2.B(); // 访问类方法 &#125;&#125; 输出结果为：T.ATest.BT.AT.BT.ATest.B static修饰变量、方法、内部类：不用实例化类，可直接通过类名.xx访问静态变量、方法、内部类。修饰代码块：对于静态代码块，仅在类加载时执行，仅执行一次。 对于定义于类中的非静态的初始化语句或代码块，这些是与对象捆绑的，这些语句将在构造方法之前执行，实际上是JVM把这些类之中的非static语句或块和构造方法合并在一起，形成了方法，每次使用new调用构造方法会使实例构造器方法执行。而static修饰的代码块，语句都合并在一起，形成方法，仅在类加载的时候执行一次。 最后再来欣赏一段代码，关于static代码块和普通代码块的执行时机，各大企业的笔试题最喜欢考了：123456789101112131415161718192021222324252627282930313233343536373839404142434445class A &#123; &#123; System.out.println("A:父类的代码块总是在父类构造方法被调用前先执行"); &#125; static &#123; System.out.println("A:父类的静态代码块是最早加载的"); &#125; int i = 0; A() &#123; System.out.println("A:父类的构造器在new子类实例时被调用"); System.out.println(++i); &#125;&#125;public class LearnStatic extends A &#123; static &#123; System.out.println("B:静态代码块只加载一次"); &#125; &#123; System.out.println("B:代码块"); &#125; LearnStatic() &#123; System.out.println("B:构造函数"); &#125;&#125;class C extends A &#123; static &#123; System.out.println("C:静态代码块甚至早于父类构造器"); &#125; &#123; System.out.println("C:代码块"); &#125; C() &#123; System.out.println("C:构造函数"); &#125;&#125; 新建一个类来测试刚才的内容：1234567public class TestLearnStatic &#123; public static void main(String[] args) &#123; LearnStatic b = new LearnStatic(); A b2 = new LearnStatic(); C c = new C(); &#125;&#125; 输出结果为 A:父类的静态代码块是最早加载的B:静态代码块只加载一次A:父类的代码块总是在父类构造方法被调用前先执行A:父类的构造器在new子类实例时被调用1B:代码块B:构造函数A:父类的代码块总是在父类构造方法被调用前先执行A:父类的构造器在new子类实例时被调用1B:代码块B:构造函数C:静态代码块甚至早于父类构造器A:父类的代码块总是在父类构造方法被调用前先执行A:父类的构造器在new子类实例时被调用1C:代码块C:构造函数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git使用]]></title>
      <url>http://blade6.top/posts/ca675cd4/</url>
      <content type="text"><![CDATA[github:ssh生成的.pub文件查看方法：cmd进入所在目录后用“more 文件名”查看。 安装git后的第一个命令：git config –global user.name “Your name”git config –global user.email “Your email” 把更新后的项目同步到本地：进入本地master分支的目录，用命令git pull进行同步，如果是git clone下来的会自动合并。具体参考《Pro Git》：http://iissnan.com/progit/ 关联已有项目：1.在github上创建项目2.在本地项目目录下git init后git remote add origin 地址3.git add. -&gt;git commit -m “” -&gt; git push origin master git init之后生成的是空文件夹，需要先git add .之后才能提交 注意暂存区存储的是文件的修改信息，不是文件本身！ 提交代码三步走：1.git add . //添加所有文件到暂存区stage2.git commit -m “提交说明” //提交暂存区的所有内容到当前分支3.git push origin master 操作整个仓库git log：显示版本库提交历史，从上到下依次是从最近到最远的提交。（使用git log –pretty=oneline简化每个commit输出为一行；git log –graph –pretty=oneline –abbrev-commit用图表显示commit历史，可以很清楚地看到merge的过程）git status：显示暂存区（Changes to be committed）和工作区（Changes not staged for commit）的状态，此命令是后悔药的使用说明。git commit -m “message”：提交暂存区的文件到版本库，相当于给当前文件拍一个快照，如果崩溃了，可以恢复到拍照的状态。git reset –hard HEAD^：回退到最新commit的上一个提交的状态，操作对象是版本库（HEAD表示最新提交的状态，加一个^表示往前推前一次，往上100个版本写成HEAD~100）git reset SHA：SHA为commit id的前七位，任意跳至想要的状态git reflog：查看commit和reset命令历史，利用里面的commit id和上一步的git reset SHA可以跳至未来的版本，有时候reset成过去的版本之后后悔想回到未来的版本可以使用。 分支管理 Git鼓励使用分支 git branch：查看分支git branch branchname：在当前分支基础上，创建名为branchname的分支（branchname分支具有和当前分支一模一样的内容）git checkout branchname：切换至branchname分支 分支的理解：1.我在master分支创建了demo.txt文件，里面写了Hello World!，提交了2.我新建了分支new，并修改demo.txt文件为Hello!，提交了3.在git bash处于new分支的时候，我打开demo.txt，看到里面写了Hello!，然后关闭了demo.txt文件4.我回到master分支，打开demo.txt文件，看到里面写了Hello World!，然后我关闭了demo.txt文件5.我关闭了git bash，打开demo.txt文件，看到里面写了Hello World!6.如果我是在new分支没有切换回master分支的情况下关闭git bash，那么打开demo.txt文件将看到Hello! git checkout -b branchname：创建并切换至branchnamegit merge branchname：合并branchname分支至本分支 合并的时候可能会conflict，此时打开文件进行修改后—&gt;注意删除干净git的标记符，再执行git add file,git commit -m “message”即可 Fast-forward合并 git merge –no-ff -m “message” branchname：禁用Fast forward合并，使用普通模式合并并提交git branch -d branchname：删除branchname分支 git stash：保存工作现场如果正在dev分支上开发，此时突然有任务，但是dev分支的开发还未完成，不能提交，那么可以保存dev工作的现场，保存现场后使用git status可以看到工作区很干净 完成任务后，需要继续开发dev分支，使用git stash list可以查看工作现场；使用git stash pop恢复时间上最新的现场也就是stash@{0}，并删除stash内容（stash是被git存储在某个地方了）;或者使用git stash apply stash@{number}恢复stash@{number}现场，然后使用git stash drop stash@{number}删除编号为stash@{number}的现场，如果直接写git stash drop则删除时间上最新的现场；git stash clear是清除所有stash。 git branch -D branchname：强行删除未合并的分支 操作单个文件 文件每次有修改的保存后，称为一个状态 git add filename：添加文件到暂存区，如果添加后又对文件做了修改，需要再次git add否则最新的修改就只是停留在工作区，因为每次git commit都是把暂存区提交到版本库。git rm filename：删除工作区文件，同时删除操作会被添加到暂存区等待提交（如果工作区和暂存区或版本库不同会报错，报错的解决方法：首先保证暂存区没有添加该文件，既然删除就完全没有道理再修改该文件；然后保证工作区和版本库的最新版本中的该文件相同，可使用git checkout – filename；最后使用本命令删除文件）git diff filename：以该文件的最新的提交为起点，输出文件当前的状态和它上一步的状态之前的区别，如果文件从未被提交过，那么不输出任何信息。 以下是我对这个命令做的一个小实验：1.假设本地有个demo.txt文件，里面的内容是”Hello World”，版本库中最新版本也是如此2.修改demo.txt为”Hello Wold”，使用命令后显示-“Hello World” +”Hello Wold”3.git add demo.txt后修改demo.txt为”Hello Wrld”，使用命令显示 -“Hello Wold”+”Hello Wrld” 4.关闭git bash后重新打开后使用命令显示内容和第3步一样5.假如我现在删除了该文件，再新建一个一模一样的，使用命令输出和第3步的输出一样6.我新建的文件写的是”Hello!”的话，输出 -“Hello World”+”Hello!” 从5,6可知：新建的文件的对比对象是版本库最新版本，即使是把原删除文件放回去，对比对象也是版本库最新版本；而第3步呈现的结果说明对于某一个文件的修改，是有线性记录的，且该记录是和该文件捆绑的） git diff HEAD – filename：查看工作区的文件和版本库里的最新版本的区别git checkout – filename：放弃对工作区文件的修改，回退到上一次git add或git commit时的状态，这个命令改变的对象是工作区（如果工作区的文件被误删了，使用此命令也可以恢复，效果也有以下两种）{如果文件修改后没有放到暂存区，该命令会使得文件和版本库的最新版本保持一致；如果文件添加到暂存区后又做了修改，该命令回到添加到暂存区时的状态}git checkout HEAD filename：用head指向的目录（版本库）替换暂存区和工作区的文件git reset HEAD filename：放弃添加到暂存区的文件，相当于git not add filename/git no rm filename，这个命令改变的对象是暂存区。 远程仓库git remote：查看远程仓库名 git remote -v：显示更详细的信息 git clone xxx DirectoryName：克隆xxx到DirectoryName目录下。 DirectoryName和.git是同级的，如果不写DirectoryName，则默认使用远程仓库的名字；xxx处可以使用https协议和ssh支持的原生git协议，后者更快，且前者每次push都要输入口令。 git clone的时候，所有本地分支默认与远程仓库的同名分支建立追踪关系，当存在追踪关系时，使用git pull或者git push都不需要写后面的远程分支名，比如git pull origin为取回x分支合并到本地的x分支，x分支为当前分支；git branch –set-upstream master origin/next：git允许手动建立追踪关系，该命令指定master分支追踪origin/next分支；如果当前分支只有一个追踪分支，使用git pull命令连远程仓库名都不需要写。 git fetch remotename：把远程仓库remotename的更新取回本地，默认取回所有分支的更新 git fetch origin master取回远程仓库origin的master分支的更新；取回的更新在本地用”remotename/branchname”的形式表示，比如使用git branch -r查看远程分支，可以看到origin/master git merge origin/master：合并origin/master分支到当前分支上git pull remotename remote-branchname:local-branchname：取回remotename的remote-branchname分支并合并到本地的local-branchname分支上 例：git pull origin next:master取回origin仓库的next分支并合并到本地的master分支上，如果写git pull origin next则为取回next分支合并到本地的当前分支上 git push remotename local-branchname:remote-branchname：把本地的local-branchname分支推送到名为remotename的远程仓库的remote-branchname分支。 省略remote-branchname的话，则表示将本地分支推送至与之具有追踪关系的远程分支，通常同名，如果该远程分支不存在，则会新建，比如git push origin master表示将本地的master分支推送到远程仓库；如果省略本地分支名，则表示删除指定的远程分支，比如git push origin :master等同于git push origin –delete master表示删除origin仓库的master分支；如果当前分支与远程分支之间存在追踪关系，则最后两个都可以省略，比如git push origin表示将当前分支推送到origin仓库的对应分支，如果当前分支只有一个追踪分支，那么可以写成git push；如果当前分支与多个远程仓库存在追踪关系，可以使用命令git push -u origin master设置origin远程仓库为当前分支的默认远程仓库，以后使用git push则会将当前分支推送到origin远程仓库的master分支 多人协作：1.首先使用git push origin branch-name推送自己的代码2.如果失败，说明远程分支比本地更新，需要先用git pull把远程的修改拉下来合并3.如果哦合并有冲突，则解决冲突，并在本地提交4.没有冲突或者解决掉冲突后，再重复步骤1 标签 默认在本地建立，不会自动推送到远程 git tag：查看所有标签git tag tagname：打标签，在某个分支下敲此命令即可（默认情况标签是打在最新提交的commit上的，如果要给历史commit打标签，则使用命令git tag tagname commit-id，commit-id为七位数）git show tagname：查看标签具体信息git tag -a tagname -m “message”：打带说明信息的标签git tag -d tagname：删除本地标签git push origin tagname：推送本地标签到远程git push origin –tags：推送全部未推送过的标签到远程git push origin :refs/tags/tagname：删除远程标签，需要先删除本地标签之后才使用这条命令删除远程的标签。 忽略特殊文件1.文件.gitignore里面写忽略的文件的名字，支持通配符*，写好后提交到git，以后git就不会把被忽略的文件提交到版本库。（Windows新建.gitignore文件是在记事本里写好了之后另存为，名称写.gitignore）2.如果某个文件被通配符忽略了（被忽略的文件无法添加到暂存区，自然无法提交到版本库），但是这个文件想特殊对待，想提交到版本库，可以使用git add -f filename强行添加到暂存区之后再提交到版本库3.如果想知道.gitignore文件里面哪条规则使某文件被忽略，可以使用命令git check-ignore -v filename查看。 自定义Gitgit config –global color.ui true：开启颜色，这样git会显示不同的颜色git config –global alias.st status：此命令告诉git，使用st作为status的别名，以后就可以敲git st而不用敲git status了（配置git时，–global是针对当前用户起作用，如果不加就只是针对当前仓库起作用；每个仓库的配置文件都放在.git/config中，而当前用户的配置文件放在用户主目录下的一个隐藏文件.gitconfig中） 参考资料廖雪峰的Git教程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java源码解读 Object类]]></title>
      <url>http://blade6.top/posts/c7aac6b0/</url>
      <content type="text"><![CDATA[getClass() Returns the runtime class of this Object. The returned Class object is the object that is locked by static synchronized methods of the represented class. 这是一个final方法，功能是在程序运行期返回调用该方法的对象所属的类的Class对象。返回的对象是由这个Class对象所表示的类（.class）的static synchronized方法锁定的对象，意思就是说，如果所表示的这个类有static synchronized方法，这个方法在执行时所锁定的那个对象和这里返回的是同一个对象。 我们常常定义class或者使用已有的class，如String，我们常常说一切皆对象，也就是一切都可以定义为class。假如我们这里把class翻译为类型，那么类型本身也是对象，那么用什么描述它？答案是Class。所以对于任意xx.class，the type of xx.class is Class。因为Class类型封装一个对象和接口运行时的状态，当装载类时，Class类型的对象自动创建。 JVM为每种类型管理一个独一无二的Class对象。每个类（型）都有一个Class对象。运行程序时，JVM首先检查是否所要加载的类对应的Class对象已经加载。如果没有加载，JVM就会根据类名查找.class文件，并将其Class对象载入。 hashCode() 在Java程序的一次执行中，对于同一个对象，每次调用hashCode()都应该返回相同的结果。但Java程序的不同执行，对于同一个对象，hashCode()方法返回的结果可以不同。 如果equals(Object)方法判断两个对象相同，则hashCode()对这两个对象应返回相同的结果。 如果两个对象不同，hashCode()方法对这两个对象可以返回相同的结果。但返回不同的结果无疑是更佳的 equals()以下都针对非null的对象： 自反性：x.equals(x)返回真 对称性：x.equals(y)返回真当且仅当y.equals(x)返回真 传递性：x.equals(y)和y.equals(z)返回真，则x.equals(z)返回真 一致性：多次调用x.equals(y)应返回一致的结果，说明没有对象发生改变。 其他：x.equals(null)返回假。为什么要针对非null对象，因为null对象无法调用equals()方法。在equals()的实现中仅有一句，return this == obj，它是内存地址的比较。 重写equals()方法，则必须重写hashCode()方法，以保证相同对象含有相同hash值。 toString()当打印引用，如调用System.out.println()时，会自动调用对象的toString()方法，打印出引用所指的对象的toString()方法的返回值，因为每个类都直接或间接地继承自Object，因此每个类都有toString()方法。源码如下：1234public String toString()&#123;return getClass().getName() + "@" + Integer.toHexString(hashCode());&#125; notify()final方法，唤醒等待对象锁的其中一个线程。选择是任意的。被唤醒的线程将无动于衷，直到当前线程（调用notify()方法的线程）让出对象锁。被唤醒的线程会和其他线程一起竞争这个对象锁，被唤醒并不意味着有privilege或者disadvantage。只有持有对象锁的线程才能调用此方法。 一个线程可以通过以下三种途径成为对象锁的主人： By executing a synchronized instance method of that object By executing the body of a synchronized statement that synchronized on the object For objects of type Class, by executing a synchronized static method of that class. 一个对象的锁在一个时刻里只能被一个线程所持有。 notifyAll()final方法，唤醒等待该对象锁的所有线程。其他和notify()方法一致。 wait()wait(long timeout)，是个final native方法：导致当前线程等待直到另一个线程在这个对象上调用notify()或者notifyAll()方法，或者是其他线程中断当前线程，或者当前线程等待了一定的时间。调用此方法的线程必须拥有这个对象的对象锁（The current thread must own this object’s monitor）。调用此方法时，当前线程会释放该对象锁，然后进入等待状态。非持锁线程调用此方法会抛出IllegalMonitorStateException；等待线程被中断会抛出InterruptedException.wait()是final方法，具体逻辑是调用wait(0)：导致当前线程等待，除非另一个线程在这个对象上调用了noitfy()或者notifyAll()方法。wait(long timeout, int nanos)也是final方法：导致当前线程等待直到另一个线程在这个对象上调用notify()或者notifyAll()方法，或者是其他线程中断当前线程，或者当前线程等待了一定的时间。注意timeout的单位是milliseconds，而nanos的单位是nanoseconds，所以当等待时间达到10^6*timeout+nanos(微秒)时，当前线程将放弃等待。 其他基本和wait(long timeout)方法一致。 clone() 在下面的描述中，拷贝是一个名词，而复制是一个动词，但二者的英译都是copy。 protected Object clone() throws CloneNotSupportedException使用这个方法的类必须实现java.lang.Cloneable接口，否则会抛出CloneNotSupportedException异常。Cloneable接口中不包含任何方法，所以实现它时只要在类声明中加上implements语句即可。这个方法是protected修饰的，覆写clone()方法的时候需要写成public，才能让类外部的代码调用。这个方法创建并返回该对象的拷贝，但是“拷贝”的含义依赖于具体的对象。这个方法实现的目的是满足下列规则： x.clone != x returns truex.clone().getClass() == x.getClass() returns true通常还会有x.clone.equals(x) returns true 这些规则并不是绝对性的要求（these are not absolute requirements）。按照惯例，我们如果通过调用super.clone来获得拷贝的话，x.clone().getClass == x.getClass()就会为真。按照惯例，拷贝和原对象应该是相互独立的。为了达成这一点，涉及到deep copy。也就是说，如果原对象内部有引用类型的话，也应该复制这些引用类型的内容而不是复制这些引用类型的内存地址。至于基本类型和不可变对象，没有deep copy这一概念。所有的数组都被认为应该去实现Cloneable接口，否则调用clone()方法最终会导致shallow copy。 finalize()垃圾收集器调用对象的该方法，当对象不再被引用时。可重写此方法来布置系统资源或者cleanup工作。可以通过此方法重新使对象活过来。但对于一个对象来说，JVM永远不会调用这个方法两次。当在此方法内部发生异常时，该异常会被忽略，然后该对象将中止。调用finalize()方法的线程不能持有用户可见的同步锁。Object类中这是个空方法，需要子类去实现具体逻辑。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[指令重排]]></title>
      <url>http://blade6.top/posts/c12d9bbd/</url>
      <content type="text"><![CDATA[节选自《实战Java高并发程序设计》，有删改 为什么要指令重排呢？让他一步一步执行多好呀！也不会那么多奇葩的问题。 之所以这么做，完全是因为性能考虑。我们知道，一条指令的执行时可以分为很多步骤的。简单地说，可以分为以下几步： 取指 IF 译码和取寄存器操作数 ID 执行或者有效地址计算 EX 存储器访问MEM 写回WB 由于每一个步骤都可能使用不同的硬件完成，因此，聪明的工程师们就发明了流水线技术来执行指令，如图1所示，显示了流水线的工作原理。 可以看到，当第2条指令执行时，第1条指令其实并未执行完，确切地说第1条指令还没开始执行，只是刚刚完成了取值操作而已。这样的好处非常明显，假如这里每一个步骤都需要花费1毫秒，那么指令2等待指令1完全执行后，再执行，则需要等待5毫秒，而使用流水线后，指令2只需要等待1毫秒就可以执行了。如此大的性能提升，当然让人眼红。更何况，实际的商业CPU的流水线级别甚至可以达到10级以上，则性能提升就更加明显。 而流水线总是害怕被中断，因为一旦中断，所有的硬件设备都会进入一个停顿期，再次满载又需要几个周期，因此，性能损失会比较大。而指令重排，就是为了减少中断而使用的技术。 让我们来看一个具体例子。图2展示了A=B+C这个操作的执行过程。写在左边的指令就是汇编指令。LW R1,B表示把B的值加载到R1寄存器中。ADD R3,R1,R2表示把R1、R2的值相加，并存放到R3中。SW A,R3表示把R3寄存器的值保存到变量A中。 注意，在ADD指令上，有一个间隔，表示一个中断。为什么会中断？原因很简单，R2的数据还没有准备好。所以，ADD操作必须进行一次等待。由于ADD的延迟，导致其后面所有的指令都要慢一个节拍。 理解了上面这个例子，我们就可以来看一个更加复杂的情况。a=b+cd=e-f上述代码的执行如图3所示。 由于ADD和SUB都需要等待上一条指令的结果，因此，在这里插入了不少停顿。那么对于这段代码，是否有可能消除这些停顿呢？显然是可以的。我们只需要将LW Re,e和LW Rf,f移动到前面执行即可。思想很简单，先加载e和f对程序是没有影响的。既然在ADD的时候一定要停顿一下，那么停顿的时间还不如去做点有意义的事情。重排后的结果如图4所示。可以看到，所有的停顿都已经消除，流水线已经可以十分顺畅地执行。 由此可见，指令重排对于提高CPU处理性能是十分必要的。虽然确实带来了乱序的问题，但是这点牺牲是完全值得的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Roman to Integer]]></title>
      <url>http://blade6.top/posts/9799a86c/</url>
      <content type="text"><![CDATA[罗马数字转整数。首先需要知道罗马数字的表示，百度一下就能找到。然后我首先想到了用HashMap把罗马符号和它对应的数字存起来，方便之后取用。于是写出了第一个程序：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public int romanToInt(String s) &#123; String[] signs = new String[]&#123; "I","II","III","IV","V","VI","VII","VIII","IX", "X","XX","XXX","XL","L","LX","LXX","LXXX","XC", "C","CC","CCC","CD","D","DC","DCC","DCCC","CM", "M","MM","MMM"&#125;; int[] number = new int[]&#123; 1,2,3,4,5,6,7,8,9, 10,20,30,40,50,60,70,80,90, 100,200,300,400,500,600,700,800,900, 1000,2000,3000 &#125;; HashMap&lt;String, Integer&gt; num = new HashMap&lt;&gt;(); for (int i = 0; i &lt; signs.length; i++) &#123; num.put(signs[i], number[i]); &#125; int length = s.length(); int result = 0; for (int i = 0; i &lt; length;) &#123; if (length - i &gt;= 4) &#123; if (num.containsKey(s.substring(i, i + 4))) &#123; result += num.get(s.substring(i, i + 4)); i += 4; continue; &#125; &#125; if (length - i &gt;= 3) &#123; if (num.containsKey(s.substring(i, i + 3))) &#123; result += num.get(s.substring(i, i + 3)); i += 3; continue; &#125; &#125; if (length - i &gt;= 2) &#123; if (num.containsKey(s.substring(i, i + 2))) &#123; result += num.get(s.substring(i, i + 2)); i += 2; continue; &#125; &#125; result += num.get(s.substring(i, i + 1)); ++i; &#125; return result;&#125; 提交后虽然AC了，但是排名12%还是不太满意。仔细看看程序，发现可以优化，VIII实际上只需要存V和I就行了，并不需要单独存储。这样一来，程序可以简化如下：12345678910111213141516171819202122232425262728293031323334public int romanToInt(String s) &#123; int result = 0; String[] signs = new String[]&#123; "I","IV","V","VI","IX", "X","XL","L","LX","XC", "C","CD","D","DC","CM", "M"&#125;; int[] number = new int[]&#123; 1,4,5,6,9, 10,40,50,60,90, 100,400,500,600,900, 1000 &#125;; HashMap&lt;String, Integer&gt; num = new HashMap&lt;&gt;(); for (int i = 0; i &lt; signs.length; i++) num.put(signs[i], number[i]); for (int i = 0; i &lt; s.length();) &#123; if (i + 1 &lt; s.length()) &#123; if (num.containsKey(s.substring(i, i+2))) &#123; result += num.get(s.substring(i, i+2)); i += 2; &#125; else &#123; result += num.get(s.substring(i, i+1)); ++i; &#125; &#125; else &#123; result += num.get(s.substring(i, i+1)); break; &#125; &#125; return result;&#125; 提交后当然也AC了，排名42%了。但是程序似乎还可以优化，比如VI不需要单独存储，因为VI可以通过V和I得到，但是如果去掉了VI、LX、DC的话，程序的执行速度是变慢的，理由很简单，因为nums.containsKey(s.substring(i,i+2))反正都要判断目前的两个字符，何必要多此一举把两个字符拆开走下面的else，这样实际上是浪费了效率。 除了上面的方法外，我还想到了另一种方法，代码如下：1234567891011121314151617181920212223242526272829303132333435363738public int romanToInt(String s) &#123; int result = 0; char[] array = s.toCharArray(); for (int i =0 ; i &lt; array.length; i++) &#123; switch (array[i]) &#123; case 'I': result += 1; break; case 'V': if (i &gt; 0 &amp;&amp; array[i-1] == 'I') result += 3; else result += 5; break; case 'X': if (i &gt; 0 &amp;&amp; array[i-1] == 'I') result += 8; else result += 10; break; case 'L': if (i &gt; 0 &amp;&amp; array[i-1] == 'X') result += 30; else result += 50; break; case 'C': if (i &gt; 0 &amp;&amp; array[i-1] == 'X') result += 80; else result += 100; break; case 'D': if (i &gt; 0 &amp;&amp; array[i-1] == 'C') result += 300; else result += 500; break; case 'M': if (i &gt; 0 &amp;&amp; array[i-1] == 'C') result += 800; else result += 1000; break; &#125; &#125; return result;&#125; 不过表现不太出色，排名26%左右。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[String to Integer(atoi)]]></title>
      <url>http://blade6.top/posts/ecbf921f/</url>
      <content type="text"><![CDATA[把字符串转整数。这是一道考察代码健壮性的题目。当我第一次写好代码以为自己很厉害时，现实很快就狠狠地打脸。我觉得代码之所以没写好，主要是想象力不够。总是有些脑回路特殊的人写出一些出乎意料的TestCase，真够变态的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public int myAtoi(String str) &#123; // 处理字符串包含空格的情况，比如" 010" str = str.trim(); if (str == null || str.length() == 0) return 0; if (str.length() == 1) &#123; if (!Character.isDigit(str.charAt(0))) return 0; return str.charAt(0) - '0'; &#125; char[] array = str.toCharArray(); // 默认为正数 boolean flag = true; int ans = 0; int index = 0; if (array[0] == '-') &#123; if (Character.isDigit(array[1])) &#123; ans = - (array[1] - '0'); flag = false; index = 2; &#125; &#125; else if (array[0] == '+') &#123; index = 1; &#125; for (; index &lt; array.length ; index++) &#123; if (Character.isDigit(array[index])) &#123; if (ans * 10 / 10 != ans) &#123; if (flag) return Integer.MAX_VALUE; else return Integer.MIN_VALUE; &#125; else ans *= 10; //System.out.println("ans: " + ans); if (flag) ans += array[index] - '0'; else ans -= array[index] - '0'; // 当为正数时，结果却为负数，说明溢出了，返回最大正整数 if (ans == Integer.MIN_VALUE &amp;&amp; flag) return Integer.MAX_VALUE; // 与上述正相反 if (ans == Integer.MAX_VALUE &amp;&amp; !flag) return Integer.MIN_VALUE; //System.out.println("ans: " + ans); &#125; else return ans; &#125; if (index == array.length) return ans; else return 0;&#125; 写出来的代码虽然AC了，但是惨不忍睹，也不便于维护。看了看leetcode大神们写的简洁的代码，每一步都是如此地恰到好处，完美地演绎Just Enough的哲学。而我等小白，路还很长。 走过的坑(TestCases)：“hello”,“15”,“-2147483647”,“01234”,“2147483648”,“3333333333”,“he123”,“+444”,“-2147483649”,“-“,“-3333333333”,“ 010”,“01 12”,“ 12 “,“ +004500”,“123hehe”,“ - 12”]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Add Two Numbers]]></title>
      <url>http://blade6.top/posts/64c8f80f/</url>
      <content type="text"><![CDATA[给定两个非空链表，计算这两个链表所代表的数字的和。比如2-&gt;3-&gt;4和3-&gt;1-&gt;7表示的数字是432和713，需要求出和1145并返回链表5-&gt;4-&gt;1-&gt;1。 解题思路对于两个链表都从左往右进行扫描，相加，注意处理边界条件（两个链表一长一短）和进位情况，算法时间复杂度为O(N)。 解法一具体描述l1指向链表1的当前结点，l2指向链表2的当前结点，l3指向结果链表的当前结点，result指向结果链表的头结点。用c表示进位情况，有进位时c为1。初始时，因为l1和l2都非空，将二者的值之和赋给l3，同时根据进位情况更改c的值。首先循环判断l1的下一个结点是否非空，若非空，令l1指向下一个结点，同时l3也指向新结点（用0创建）。判断l2的下一个结点是否非空，来决定是把l1的值赋给l3还是把两链表结点值之和赋给l3，不要忘了进位情况。循环结束条件为l1所在链表没有更多结点了。然后循环循环判断l2的下一个结点是否非空，此循环在链表1的长度比链表2的要短时有效。把链表2的剩余结点的值逐个赋给结果链表。不要遗漏最后一个结点有进位的情况。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode l3 = new ListNode(0); ListNode result = l3; int c = 0; if(l1.val+l2.val&lt;10) l3.val = l1.val+l2.val; else&#123; l3.val = l1.val + l2.val - 10; c = 1; &#125; while(l1.next != null)&#123; l1 = l1.next; l3.next = new ListNode(0); l3 = l3.next; if(l2.next != null)&#123; l2 = l2.next; if(l1.val+l2.val+c&lt;10)&#123; l3.val = l1.val+l2.val+c; if(c==1) c=0; &#125;else&#123; l3.val = l1.val + l2.val + c - 10; c = 1; &#125; &#125;else&#123; if(l1.val + c &lt; 10)&#123; l3.val = l1.val + c; if(c==1) c=0; &#125;else&#123; l3.val = l1.val + c - 10; c = 1; &#125; &#125; &#125; while(l2.next != null)&#123; l2 = l2.next; l3.next = new ListNode(0); l3 = l3.next; if(l2.val + c &lt; 10)&#123; l3.val = l2.val + c; if(c==1) c=0; &#125;else&#123; l3.val = l2.val + c - 10; c = 1; &#125; &#125; if(c==1)&#123; l3.next = new ListNode(1); &#125; return result; &#125;&#125; 提交后AC通过，运行时间57ms，排名59%。这个代码的缺点是每次都用0去初始化新结点，然后再修改新结点的值，造成时间浪费。同时整体结构不够精简，有比较多的重复代码，不能让人一眼明白程序在做什么。 解法二具体描述详见代码，代码是在观摩了众大神的代码后，稍微润色了一下，非常地简单优雅，一目了然。第29行return result.next;干得漂亮！ 代码1234567891011121314151617181920212223public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode l3 = new ListNode(0); ListNode result = l3; int sum = 0; int carry = 0; while (l1 != null || l2 != null || carry != 0) &#123; sum = carry; if (l1 != null) &#123; sum += l1.val; l1 = l1.next; &#125; if (l2 != null) &#123; sum += l2.val; l2 = l2.next; &#125; carry = sum / 10; l3.next = sum &lt; 10 ? new ListNode(sum) : new ListNode(sum - 10); l3 = l3.next; &#125; return result.next; &#125;&#125; 提交后AC，运行时间51ms，排名91%。P.S.代码运行速度每减少1ms，幸福度增加10%。P.S.S 其实我一开始写的代码略微有点不同，第18行写的是l3.next = new ListNode(sum % 10);，但是提交后提示超时，不知道leetcode搞什么飞机，没办法，我觉得代码是对的，又不想做修改，只好稍微修改敷衍一下。 帮助自己在本地编写代码调试时，可以对ListNode进行扩展，方便调试代码。 ListNode1234567891011121314151617181920212223242526public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; // 打印ListNode的每个值 public static void print (ListNode temp) &#123; while (temp != null) &#123; System.out.print(temp.val + "-&gt;"); temp = temp.next; &#125; System.out.println(); &#125; // 根据整数数组创建ListNode public static ListNode create (int[] nums) &#123; ListNode result = new ListNode(0); ListNode index = result; for (int num : nums) &#123; ListNode cur = new ListNode(num); index.next = cur; index = index.next; &#125; return result.next; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Longest Substring Without Repeating Characters]]></title>
      <url>http://blade6.top/posts/8e8877f3/</url>
      <content type="text"><![CDATA[给定字符串，求出它的不重复最长子串的长度。以下提供两种方法，时间复杂度都是O(N)级别，但因为O(N)只是描述了一个上界，而且是很模糊的，所以以下两个算法的真实运行时间还是有差异的。不过以下两个算法在本质上都是一样的，读者通读代码后不难发现这一点。 方法一解题思路对于字符串s，用指针i从左往右顺序扫描该字符串，用temp记录当前的子字符串。当i所指向的字符未在temp中出现时，则temp加上i所指向的字符，同时i右移一位。当i所指向的字符x已经出现了时，判断temp的长度和最大值max，以决定是否将temp的长度赋给max。则temp应自行截断从起点到x为止的字符串，然后temp的剩余部分加上i所指向的字符构成新的temp，同时i右移一位。需要注意的是整个循环结束后，仍然要判断temp的长度和max的大小，因为循环体会漏掉最后一次判断。 代码1234567891011121314151617181920212223public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if(s.length()==0) return 0; else if(s.length()==1) return 1; int max = 0; String temp = "" + s.charAt(0); int i = 1; while(i&lt;s.length())&#123; if(temp.indexOf(s.charAt(i)) &gt;= 0)&#123; if(temp.length() &gt; max) max = temp.length(); int index = temp.indexOf(s.charAt(i)) + 1; temp = temp.substring(index) + s.charAt(i); ++i; &#125; else&#123; temp += s.charAt(i); ++i; &#125; &#125; if(temp.length() &gt; max) max = temp.length(); return max; &#125;&#125; 此处贴的是AC了的代码，期间失败多次，不一一详述。运行速度排名47%。 方法二解题思路对于字符串s，把它转化为字符数组str，数组可以随机存取，可以加快存取速度，str的每个元素都是一个字符。因为C语言中char的范围是-128~127，所以可以肯定TestCase的字符都是在这个范围里面的。所以虽然我是用Java写的，但是我仍然使用了一个布尔值的数组exist，长度为256，判断每个字符是否已经存在于子字符串中。初始时令head指向str的第1个元素，tail指向str的第2个元素，同时将exist[str[0]]置为true，表示str的第1个元素在子字符串中已出现，所谓子字符串，指的是str的下标head到tail的区域的字符组合。然后tail不断右移。对于tail指向的元素，如果未在子字符串中出现，那么将tail指向的元素标记为已出现，同时tail右移一位。如果tail指向的元素已经在子字符串中出现了，那么head不断右移，在右移的过程中，每右移一位表示将一个元素踢出子字符串，这时要把踢出去的元素标记为未出现，因为已经被踢出去了，子字符串中不包含该元素了。右移的结束条件是将和tail指向的元素相同的元素踢出子字符串，这时head指向这个被踢出元素的下一个位置，同时tail指向下一个位置，不需要将最后踢出的元素标记为未出现，因为最后踢出的元素和加入的元素是同一个元素。需要注意的地方和方法一相同，都是在循环的过程中会遗漏最后一次比较。 代码123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if (s.length() == 0 || s.length() == 1) return s.length(); char[] str = s.toCharArray(); //存在数组 boolean[] exist = new boolean[256]; //记录最大值 int max = 1; //头指针和尾指针 int head = 0, tail = 1; exist[str[0]] = true; while (tail &lt; str.length) &#123; if (exist[str[tail]]) &#123; if (tail - head &gt; max) max = tail - head; //头指针要指向与尾指针相同字符的下一个位置 //比如"abcdcef" //当tail指向第2个c时，head要指向d while (head &lt; tail) &#123; if (str[head] == str[tail]) &#123; ++head; ++tail; break; &#125; else &#123; exist[str[head]] = false; ++head; &#125; &#125; &#125; else &#123; exist[str[tail]] = true; ++tail; &#125; &#125; if (tail -head &gt; max) max = tail - head; return max; &#125;&#125; 提交后AC，运行速度排名99%。 测试代码用于测试算法是否正确，包含一些典型的TestCase。1234567891011public class Test &#123; public static void main(String[] args) &#123; Solution demo = new Solution(); String[] test = new String[]&#123;"abcabcbb", "bbbbb", "pwwkew", "au", "c", "dvdf", "", "bab", "abcdbef", "abcdcef"&#125;; for (String s : test) System.out.println(s + ":" + demo.lengthOfLongestSubstring(s)); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Maximum Subarray]]></title>
      <url>http://blade6.top/posts/b8913e5e/</url>
      <content type="text"><![CDATA[给定数组，求数组中的所有子串中最大的子串和。很容易就能想到O(n^3)的算法，一个一个遍历，但一定会超时的。下面介绍两种方法，第一种的时间复杂度为O(NlogN)，但是仍然超时，第二种为O(N)。 分治法解题思路对于给定数组，可以把该数组分成两部分，左半部分和右半部分。对于该数组的最大的子串和，要么出现在左半部分，要么出现在右半部分，要么出现在左半部分和右半部分的交叉部分。对于交叉部分，一定是从中间向两侧扩散的，写代码的时候要注意这一点。 代码如下1234567891011121314151617181920212223242526272829public class Solution &#123; public int maxSubArray(int[] nums) &#123; return maxSum(nums, 0, nums.length-1); &#125; public int maxSum(int[] nums, int left, int right) &#123; if (left == right) return nums[left]; int center = (left + right) / 2; int maxLeft = maxSum(nums, left, center); int maxRight = maxSum(nums, center+1, right); int maxLeftBorder = nums[center], leftBorder = nums[center]; for (int i = center-1; i &gt;= left; i--) &#123; leftBorder += nums[i]; if (leftBorder &gt; maxLeftBorder) maxLeftBorder = leftBorder; &#125; int maxRightBorder = nums[center+1], rightBorder = nums[center+1]; for (int j = center+2; j &lt;= right; j++) &#123; rightBorder += nums[j]; if (rightBorder &gt; maxRightBorder) maxRightBorder = rightBorder; &#125; return Math.max(Math.max(maxLeft, maxRight), maxLeftBorder+maxRightBorder); &#125;&#125; 循环的结束条件只判断了left==right的情况，left&gt;right的情况是不会出现的，利用反证法可以轻易证明，此处不展开叙述。 但是提交后仍然超时了。善良的leetcode在结果页面上告诉了我202个Testcase都通过了，代码本身是正确的，只是用时过长。 一次扫描法解题思路因为leetcode对题目做了限定，返回的最大子串和所在的子串至少包含一个数，换言之数组中所有数都是负数的情况下，最大子串和必然是最大的那个负数，这就是情况1。情况2：当所有数都是非负数，最大子串和就是数组中所有数的和。情况3：当输入的数组有正数有负数时，令max=0，temp=0，max表示最大子串和，因为数组中有正数，所以max的值会在循环中被改变，不会一直保持为0。temp表示当前的子串和。令指针i初始时指向数组第一个元素，i每次向后移动一位。对于i当前指向的元素，把它加到temp里。然后判断temp和max的大小，决定是否把temp的值赋给max。如果temp&lt;max时，还要判断temp的值是否小于0，如果小于0，则temp=0，表示舍弃temp所表示的子串，从该子串的下一个数开始求最大子串和，此处可以用反证法证明如下：若temp表示从下标m到n的子串和，假设我们最终求得的最大子串和MAX是从下标m到n+p的子串的和。那么MAX=temp+nums[n+1]+...+nums[n+p]，而又因为temp&lt;0，则存在REAL_MAX=nums[n+1]+...+nums[n+p]&gt;MAX，这与假设矛盾。 情况2和情况3可以一起处理，情况1需要特殊处理。 代码123456789101112131415161718192021222324public class Solution &#123; public int maxSubArray(int[] nums) &#123; int max = 0, temp = 0; boolean flag = false; for (int i = 0; i &lt; nums.length; i++) &#123; temp += nums[i]; if (temp &gt; max) max = temp; else if (temp &lt; 0) temp = 0; //如果数组中存在非负数，且flag为false的话， //flag置为true表示数组中存在非负数 if (!flag &amp;&amp; nums[i] &gt;= 0) flag = true; &#125; if (flag) return max; else &#123; int N_max = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i] &gt; N_max) N_max = nums[i]; &#125; return N_max; &#125; &#125;&#125; 提交后代码AC了，运行速度排名在67%左右。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Generate Parentheses]]></title>
      <url>http://blade6.top/posts/c59bb016/</url>
      <content type="text"><![CDATA[给定n，求n对括号可以生成的括号嵌套种数。这道题其实不难，很快就能想出解题思路。 解题思路对于n，记录的是括号的数目，本质上也是左括号和右括号的出现次数。假设t记录左括号的剩余出现次数，cur记录当前未匹配的左括号个数，str记录单次结果，str的长度是固定的，必然是2n。首先要初始化：t=n，cur=0，str=””。当循环开始时，第1个符号必须是左括号，然后t-=1，表示左括号的剩余出现次数变成n-1了。同时str+=”(“，cur+=1，表示str中有1个左括号未匹配。对于第i个符号：如果t==0且cur==0，说明循环结束，将str加到结果集中。如果t==0，说明左括号的剩余出现次数已用完，那么第i个符号只能取右括号，同时cur-=1；如果cur==0，说明str中不存在未匹配的左括号，那么第i个符号只能取左括号，同时t-=1；如果t&gt;0且cur&gt;0，则第i个符号可以是左括号也可以是右括号，如果第i个符号取左括号，那么t-=1，cur+=1，如果第i个符号取右括号，那么cur-=1。注意：因为对于第i个符号，当t&gt;0且cur&gt;0的时候，第i个符号可以有两种取值，所以使用递归会取得事半功倍的效果。 代码1234567891011121314151617181920public class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; l = new ArrayList&lt;String&gt;(); test(l, n, 0, ""); return l; &#125; public void test(List&lt;String&gt; l, int t, int cur, String str)&#123; if(t==0 &amp;&amp; cur == 0)&#123; l.add(str); &#125;else if(cur == 0)&#123; test(l, t-1, cur+1, str+"("); &#125;else if(t==0)&#123; test(l, t, cur-1, str+")"); &#125;else&#123; test(l, t-1, cur+1, str+"("); test(l, t, cur-1, str+")"); &#125; &#125;&#125; 一次AC通过，运行速度排名39%。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Merge Two Sorted Lists]]></title>
      <url>http://blade6.top/posts/a72883c7/</url>
      <content type="text"><![CDATA[合并两个有序链表。因为是链表，所以可以写出空间复杂度为O(1)的算法。 解题思路对于这两条链表，给定指针l1和l2，分别指向两条链表的结点。给定指针result，指向结果链表的尾结点。每次比较l1指向结点和l2指向结点的值的大小，然后把小的那个结点插入到结果链表的尾部，同时使存储该结点的指针指向其下一个结点，结果链表的指针result指向下一个结点。注意result每次都指向结果链表的尾结点，而不是尾结点的next部，否则会导致空指针错误。操作如图：橙色为上一步，蓝色为下一步。 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1 == null) return l2; if(l2 == null) return l1; //对于两个链表的第一个结点的比较单独写出来， //因为需要初始化result_head，result_head指向结果链表的第一个结点 ListNode result = null; if(l1.val &lt;= l2.val) &#123; result = l1; l1 = l1.next; &#125; else &#123; result = l2; l2 = l2.next; &#125; ListNode result_head = result; while(true) &#123; if(l1 == null) &#123; result.next = l2; break; &#125; else if (l2 == null) &#123; result.next = l1; break; &#125; else &#123; if(l1.val &lt;= l2.val) &#123; result.next = l1; l1 = l1.next; &#125; else &#123; result.next = l2; l2 = l2.next; &#125; result = result.next; &#125; &#125; return result_head; &#125; &#125; 提交后AC，运行速度排名60%左右。 还可以使用分治法，可以写出简短易懂的代码。1234567891011121314public class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1 == null) return l2; if(l2 == null) return l1; if(l1.val &lt;= l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Pow(x,n)]]></title>
      <url>http://blade6.top/posts/bbe3cb45/</url>
      <content type="text"><![CDATA[这道题是实现内置函数pow(x,n)。思路没什么复杂的，我很快就想出了第一个答案：123456789101112131415161718public class Solution &#123; public double myPow(double x, int n) &#123; if (n == 0) return 1.0; if (n == 1) return x; int m = n; if(n &lt; 0) m = -n; double result = x; while(m &gt; 1) &#123; result *= x; --m; &#125; if(n &lt; 0) return 1 / result; return result; &#125;&#125; 然后也很快地死在以下TestCase：0.000012147483647死亡原因：超时。 超时的原因很简单，我的算法是一个O(n)级别的算法。而事实上存在O(log n)级别的算法。所以，分治法出场了。 解题思想对于x^n，通常可以这样做：如果n是奇数，那么x^n等价于(x*x)^(n/2)*x;如果n是偶数，那么x^n等价于(x*x)^(n/2). 有了思想，很快就写出了代码：123456789101112131415public class Solution &#123; public double myPow(double x, int n) &#123; if(n == 0) return 1.0; if(n == 1) return x; if(n &lt; 0) return 1 / My_pow(x, -n); else return My_pow(x, n); &#125; public double My_pow(double x, int m) &#123; if(m == 1) return x; if(m % 2 == 0) return My_pow(x*x, m/2); return My_pow(x*x, m/2) * x; &#125;&#125; 提交后死在以下TestCase上：1.00000-2147483648死亡原因：运行时错误（栈溢出）P.S.仔细一看，就能发现错误。但当时我没有意识到。后来我修改了My_pow()方法，在第一行加上了if (m == 0) return 1.0;，提交后就AC了，运行速度排名70%左右。 当时看到栈溢出的错误时，我第一感觉是使用了递归导致的，于是试图实现使用循环代替递归，但是以失败告终。经过在网上搜索，对比别人的代码，我修改代码如下：1234567891011121314151617public class Solution &#123; public double myPow(double x, int n) &#123; if(n == 0) return 1.0; if(n == 1) return x; if(n == Integer.MIN_VALUE) return 1 / (My_pow(x, Integer.MAX_VALUE) * x); if(n &lt; 0) return 1 / My_pow(x, -n); else return My_pow(x, n); &#125; public double My_pow(double x, int m) &#123; if(m == 0) return 1.0; if(m == 1) return x; double half = My_pow(x, m/2); return half * half * My_pow(x, m%2); &#125;&#125; 提交后AC了，运行速度排名44%。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ZigZag Conversion]]></title>
      <url>http://blade6.top/posts/6d08e17c/</url>
      <content type="text"><![CDATA[一开始看到题目的时候，我是搞不清楚情况的。主要原因是不明白ZigZag的意思。 ZigZag比如有数字序列0,1,2,3，…，12，按照ZigZag排序如下：1230 4 8 121 3 5 7 9 112 6 10 ZigZag的含义就是锯齿形的，之字形的，Z字形的。现在问题明白了，给定字符串s和行数numRows，把字符串按照ZigZag排列，然后逐行按列读取，形成一个新的字符串，返回这个字符串。 解题思路这道题其实就是找规律。找到规律，代码写起来也很快。那么规律是什么呢？通过实例来捋一捋：对于给定的字符串s，它的每一个字符都应该有一个下标，这样就会形成一个下标序列，从0到s.length()-1。假设我们现在有0到20这21个数，是某个字符窜的下标序列。如果给定的numRows=6，那么把这个字符串按照ZigZag排列应该如下：1234560 10 201 9 11 192 8 12 183 7 13 174 6 14 165 15 规律如下：对于每一行的首个元素，其实是很好确定的，就是从0到numRows-1;对于首行和末行，每一个数都恰好是其前一个数加上2numRows-2;对于中间行，分成奇数位元素和偶数位元素处理，对于奇数位元素，每一个数都恰好是其前一个数加上2numRows-2，偶数位元素也是如此。 思路捋顺了，规律找到了，我们开始写代码：123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; public String convert(String s, int numRows) &#123; int length = s.length(); if (length == 1 || numRows == 1 || numRows &gt;= length) return s; StringBuilder result = new StringBuilder(); for (int i = 0; i &lt; numRows; i++) &#123; result.append(s.charAt(i)); if (i == 0 || i == numRows - 1) &#123; int j = i + 2 * numRows - 2; while (j &lt; length) &#123; result.append(s.charAt(j)); j += 2 * numRows - 2; &#125; &#125; else &#123; //int Odd = (numRows - 1) + [(numRows -1) - i] int Odd = 2 * numRows - 2 - i; if (Odd &lt; length) result.append(s.charAt(Odd)); int Even = i + 2 * numRows - 2; if (Even &lt; length) result.append(s.charAt(Even)); while (true) &#123; Odd += 2 * numRows - 2; if (Odd &lt; length) result.append(s.charAt(Odd)); else break; Even += 2 * numRows - 2; if (Even &lt; length) result.append(s.charAt(Even)); else break; &#125; &#125; &#125; return result.toString(); &#125; &#125; 需要注意的地方如下：1.对于字符串s，考虑s的长度小于numRows的情况。2.对于每次处理到的下标，除非当前下标是每一行的首个元素，否则需要判断该下标是否越界。3.中间行的奇数位元素的首个元素需要结合当前行进行判断。 提交代码，AC，运行时间53ms，排名84%。这次运气不错，一次运行通过。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Median of Two Sorted Arrays]]></title>
      <url>http://blade6.top/posts/757ce68a/</url>
      <content type="text"><![CDATA[要求出两个有序数组的中位数，试想，如果我们能够求出两个有序数组合并后的第k个数，那么中位数只是一种特殊情况，问题迎刃而解。题目要求时间复杂度要在O(log(m+n))，通常出现对数，应该考虑分治法。 解题思路求解两个有序数组的第k个数：假设给定有序数组A和B,A的前指针aLow和后指针aHigh，B的前指针bLow和bHigh，以及k。求出A数组区间[aLow,aHigh]的中间数A[aMid]，B也做同样操作，同时求出A[aLow,aMid]和B[bLow,bMid]一共有多少个数并赋给HalfPart注意是闭区间，所以A[aMid]和B[bMid]都包含在HalfPart里面，HalfPart=A[aLow,aMid]+B[bLow,bMid]。 然后判断A[aMid]和B[bMid]的大小。如果A[aMid]==B[bMid]，那么判断HalfPart和k的大小。HalfPart&gt;k说明第k个数应该出现在A[aLow,aMid]和B[bLow,bMid]所包含的数里，否则出现在A[aMid+1,aHigh]和B[bMid+1,bHigh]所包含的数里。如果A[aMid]!=B[bMid]，那么也是同样判断HalfPart和k的大小。当A[aMid]k，则说明第k个数不会出现在B[bMid,bHigh]里面，但无法判断第k个数在A中的出现情况。理由如下：如果A[aMid]&lt;B[bMid]&amp;&amp;HalfPart&gt;k，那么我们可以增加一个变量x=aMid，令x自增，直至A[x]==B[bMid]，假设把这两个有序数组进行合并的话，B[bMid]应该出现在x+bMid这个位置上,因为HalfPart&gt;k，同时又有x&gt;aMid，则易知x+bMid=A[aLow,x]+B[bLow,bMid]&gt;HalfPart&gt;k，则B[bMid]是一个合并排序后的第k+u个数（u是未知数），而我们要求的是第k个数，所以第k个数不会出现在B[bMid,bHigh]里面。第k个数有可能出现在A[aLow,x]和B[bLow,bMid-1]这个范围里面。如果HalfPart&lt;=k，则说明第k个数不会出现在A[aLow,aMid]里面，但无法判断在B中的出现情况。理由类似上述。P.S.注意当HalfPart&gt;k时，舍弃了B[bLow,bHigh]，舍弃的是高下标的数据，不会影响我们查找第k个数。但是当HalfPart&lt;=k时，舍弃的是A[aLow,aMid]，这实际修正了我们的查找目标，不再是第k个数，而是第k-(aMid-aLow+1)个数。对于A[aMid]&gt;B[bMid]的情况，相当于互换了A和B的位置，思路还是一样。 分析完毕，可以开始写代码了。1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int length = nums1.length + nums2.length; if (length % 2 == 0) return (findKth(nums1, nums2, length / 2) + findKth(nums1, nums2, length / 2 + 1)) / 2.0; else return findKth(nums1, nums2, (length + 1) / 2); &#125; /* * find the k num in two sorted arrays * recursion */ public int findK(int[] A, int a_low, int a_high, int[] B, int b_low, int b_high, int k) &#123; if (a_low &gt; a_high) return B[b_low + k - 1]; if (b_low &gt; b_high) return A[a_low + k - 1]; //if (a_high == a_low &amp;&amp; b_high == b_low &amp;&amp; A[a_low] == B[b_low]) return A[a_low]; int a_mid = a_low + (a_high - a_low) / 2; int b_mid = b_low + (b_high - b_low) / 2; int half_part = a_mid - a_low + b_mid - b_low + 2; if (A[a_mid] == B[b_mid]) &#123; if (half_part &lt; k) return findK(A, a_mid + 1, a_high, B, b_mid + 1, b_high, k - half_part); else return findK(A, a_low, a_mid, B, b_low, b_mid, k); &#125; else if (A[a_mid] &lt; B[b_mid] ) &#123; if (half_part &lt;= k) return findK(A, a_mid + 1, a_high, B, b_low, b_high, k - (a_mid - a_low + 1)); else return findK(A, a_low, a_high, B, b_low, b_mid - 1, k); &#125; else &#123; if (half_part &lt;= k) return findK(A, a_low, a_high, B, b_mid + 1, b_high, k - (b_mid - b_low + 1)); else return findK(A, a_low, a_mid - 1, B, b_low, b_high, k); &#125; &#125;&#125; 运行代码死在了以下TestCase：[1][1]死亡原因：运行错误，经本地调试发现是栈溢出。实际上是由于代码第26行造成的，死循环最终导致栈溢出。修正方法：将第18行的注释去掉。当两个数组都只剩一个数，且两数组的剩下的数还是同一个数时，则返回这个数。修正后AC通过，运行速度排名45%。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[3Sum]]></title>
      <url>http://blade6.top/posts/92e6a03a/</url>
      <content type="text"><![CDATA[3数和为0问题，对于这个问题，网上一致认为，这个问题是两数和问题的升级版，最终能够优化到O(n^2)级别。 解题思路对于给定数组中的每个下标i，用前指针left指向其下一个数，后指针right指向数组最后的数。如果三个数的和为0，则判断结果是否已出现，如果出现过，不添加，否则添加到结果集。如果三数和小于0，则前指针指向后一个数，否则后指针指向前一个数。根据解题思路，结合网上找到的别人的代码，我迅速地写出了第一个答案：123456789101112131415161718192021222324252627282930313233343536373839public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Arrays.sort(nums); int length = nums.length; for (int i = 0; i &lt; length; i++) &#123; int left = i + 1; int right = length - 1; while (left &lt; right) &#123; int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(nums[i]); list.add(nums[left]); list.add(nums[right]); if (!Compare(result, list)) result.add(list); ++left; --right; &#125; else if (sum &lt; 0) &#123; ++left; &#125; else &#123; --right; &#125; &#125; &#125; return result; &#125; public boolean Compare(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; list) &#123; for(int i = 0; i &lt; result.size(); i++) &#123; List&lt;Integer&gt; test = result.get(i); if (test.contains(list.get(0)) &amp;&amp; test.contains(list.get(1)) &amp;&amp; test.contains(list.get(2))) return true; &#125; return false; &#125; &#125; 通过Compare方法去重。然后死在了以下TestCase：[-4,-2,1,-5,-4,-4,4,-2,0,4,0,-2,3,1,-5,0]死亡原因：程序运行的结果集不正确，缺少[0,0,0]。我自个分析，原因在于Compare方法有错误，如果有一个结果（比如：[-4,4,0]）包含0和两个相反数，则[0,0,0]无法添加到结果集。而且这个方法需要对结果集做一个遍历，效率太低。 自己的代码too young too naive,我决定模仿现成的代码，从网上找到一段代码，Submit：123456789101112131415161718192021222324252627282930public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Arrays.sort(nums); int length = nums.length; for (int i = 0; i &lt; length; i++) &#123; int left = i + 1; int right = length - 1; while (left &lt; right) &#123; int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(nums[i]); list.add(nums[left]); list.add(nums[right]); result.add(list); ++left; --right; &#125; else if (sum &lt; 0) &#123; ++left; &#125; else &#123; --right; &#125; &#125; &#125; Set set = new HashSet&lt;&gt;(result); result = new ArrayList&lt;List&lt;Integer&gt;&gt;(set); return result; &#125;&#125; 这次313个TestCase，死在了第313个，也就是最后一个变态TestCase上：[0,…,0]0的出现次数有数千次之多。。死亡原因：Time Limit Exceeded 这个方法的优点自然是利用集合的无序性来达到去重的效果。缺点则是这是一个事后弥补的方法。对于每次得出的结果，则将该结果加入结果集。最后再对结果集进行筛选去重。为什么不在加入前先去重？ 根据这个TestCase，经过一番反省后，我想出两种办法来去重，第一种是采用过滤方法，第二种是备忘录方法。过滤方法的原理是，对于给定数组nums，如果其中有一个数出现了三次，那么除非这个数是0，否则第三次出现是没有意义的，因为我们最多也只会用到两个。举例来说：[4,-2,-2,-2]三数和为0的结果为[4,-2,-2]，-2在nums中出现了三次，其实出现两次就已经能得到结果[4,-2,-2]了，所以第三个-2是无效的。但0是可以出现三次的。对于任意数，出现了三次以上，就会有很多无效的数，这些数不会改变最终结果，但却会耗费大量运算时间。可以通过对nums进行过滤，剔除出现次数在3次以上的数，使得其出现次数减少至2次，0可以保持3次。第二种方法是备忘录方法，因为最终求和是nums[i]+nums[left]+nums[right]，nums[left]+nums[right]其实存在重复运算的可能性，说不定能存起来，以便下次调用，减少运算次数，但这样一想，感觉方法要走向动态规划了。 这两个idea都是在对nums做过滤，避免因为某个数的出现次数过多而做无用功，在一定程度上能够减少运算次数。但是回到问题本身，问题里给出了一个TestCase：[-1, 0, 1, 2, -1, -4]，上面的两个idea最终都会使输入的数组变成类似这样的形式（任意一个数的出现次数不会超过2次，0可以出现3次）。但这不是最优的形式。因为即使是这样的形式，还是存在重复运算。比如有TestCase：[-4,-4,2,2]。根据解题思路，在整个程序跑的过程中，会出现以下情况：1.当i=0,left=2,right=3时，得到结果[-4,2,2]，将其加入结果集；2.当i=1,left=2,right=2时，得到结果[-4,2,2]，不加入结果集。程序优化的目标就是使得情况2不要出现，因为情况2和情况1是一样的情况。对于每个i，如果array[i]==array[i-1]，那么可以跳过array[i]，因为它的情况和它的前一个数的情况相同。相应地left、right也可以做同样处理。 最终可以编写出如下的代码：1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Arrays.sort(nums); int length = nums.length; for (int i = 0; i &lt; length - 2; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; int left = i + 1; int right = length - 1; while (left &lt; right) &#123; int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(nums[i]); list.add(nums[left]); list.add(nums[right]); result.add(list); ++left; --right; while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) left++; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right--; &#125; else if (sum &lt; 0) &#123; ++left; &#125; else &#123; --right; &#125; &#125; &#125; Set set = new HashSet&lt;&gt;(result); result = new ArrayList&lt;List&lt;Integer&gt;&gt;(set); return result; &#125;&#125; 这个代码被AC了，但是运算速度排在18%左右。仔细想想，我们可以知道实际上对i、left、right进行处理后，情况2是不会出现的，其实也不需要去重了。所以可以对代码做进一步的优化，如下：1234567891011121314151617181920212223242526272829public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Arrays.sort(nums); int length = nums.length; for (int i = 0; i &lt; length - 2; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; int left = i + 1; int right = length - 1; while (left &lt; right) &#123; int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) &#123; result.add(Arrays.asList(nums[i], nums[left], nums[right])); ++left; --right; while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) left++; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right--; &#125; else if (sum &lt; 0) &#123; ++left; &#125; else &#123; --right; &#125; &#125; &#125; return result; &#125;&#125; 提交之后自然是AC了，运算速度排名在65%。 回过头来看我的那两个idea，真是太稚嫩了。nums在排序后，去重其实是很容易做到的，通过指针的移动即可完成，我却还试图费大功夫来实现一个效果不见得好的去重，而忽视排序所带来的便利，一叶障目，不见泰山。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java方法参数——值传递]]></title>
      <url>http://blade6.top/posts/c9c9e9c7/</url>
      <content type="text"><![CDATA[Java中的方法的参数是值传递还是引用传递争论已久，实际上取决于我们怎么定义这两个名词，但如果仅从定义层面去分辨，还是很难有比较好的效果。本文通过实例讲解。 基本数据类型这毫无疑问是值传递，换言之形参和实参互不影响。1234567891011public class Test1 &#123; public static void change(int a)&#123; a=50; &#125; public static void main(String[] args) &#123; int a=10; System.out.print(a + " "); change(a); System.out.print(a); &#125;&#125; 输出结果为：10 10 引用类型（数组、对象）注意形参实际上获得的是实参的一份拷贝，形参和实参都指向同一块内存地址。1234567891011public class Test &#123; public static void change(int []a)&#123; a[0]=50; &#125; public static void main(String[] args) &#123; int []a=&#123;10,20&#125;; System.out.print(a[0] + " "); change(a); System.out.print(a[0]); &#125;&#125; 输出结果为：10 50 String类String类实际上和引用类型一样，但又有一些不同。不同的地方在于String类的内容不可变，这就是String类之所以特殊的地方。123456789101112public class Test &#123; public static void change(String s2)&#123; s2="goodbye"; &#125; public static void main(String[] args) &#123; String s1=new String("hello"); System.out.print(s1 + " "); change(s1); System.out.print(s1); &#125;&#125; 输出结果为：hello hello当调用change()方法时，把s1的值（”hello”的内存地址）传递过去，s2的值将会和s1的值相同；当执行语句s2=”goodbye”时，将”goodbye”的内存地址赋给s2，此时s2的值和s1的值不再一致。所以s1的内容没有发生变化。P.S.而对于对象、数组，它们的数据域不一定是不可变对象，所以是可以通过使用形参改变的，于是出现了String类表现特殊的情况。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Longest Palindromic Substring]]></title>
      <url>http://blade6.top/posts/8872b998/</url>
      <content type="text"><![CDATA[问题：给定字符串s，求出其最长回文子串。方法一：动态规划。思想描述：假设 s[i][j] 表示字符串 s 下标从 i 到 j 的子串，如果该子串是回文子串，则令 dp[i][j] 为 true 。如果我们已经得到了最优解，这个最优解是 s[i][j] ，无疑 dp[i][j] = true 。而 dp[i][j]=true 实际上等价于 dp[i+1][j-1] = true &amp;&amp; s[i] == s[j] ，这就是推导式。考虑 i+1 == j-1 ， i+1 == (j-1)-1 ，分别对应回文子串长度为1和为2的情况，这就是基准情况：a. dp[i][i] = trueb. dp[i][i+1] = true if s[i] == s[i+1] 代码如下：12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; //Dynamic Programming public String longestPalindrome(String s) &#123; if(s.length()==0 || s.length() == 1) return s; int length = s.length(); int max = 1; String result = "" +s.charAt(0); boolean[][] dp = new boolean[length][length]; for(int i=0;i&lt;length;i++) dp[i][i] = true; for(int i=0;i&lt;length-1;i++)&#123; if(s.charAt(i) == s.charAt(i+1))&#123; dp[i][i+1] = true; if(max != 2)&#123; max = 2; result = s.substring(i, i+2); &#125; &#125; &#125; for(int i = length - 3; i &gt;= 0; i--)&#123; for(int j = i+2; j &lt; length; j++)&#123; if(dp[i+1][j-1] &amp;&amp; s.charAt(i) == s.charAt(j))&#123; dp[i][j] = true; if(j-i+1 &gt; max)&#123; max = j-i+1; result = s.substring(i, j+1); &#125; &#125;else&#123; dp[i][j] = false; &#125; &#125; &#125; return result; &#125; &#125; 需要注意的地方：实现动态规划时，需要注意边界，从哪里开始，到哪里结束。 方法二：中心扩展。思想描述：回文串是中心对称的，以 s[i] 为中心，用两个指针向两侧扩展判断是否相等可以得到以s[i]为中心的回文子串，对s的每个字符重复此操作，最终可以求得最大回文子串。 代码如下：123456789101112131415161718192021222324252627282930public class Solution &#123; public String longestPalindrome(String s)&#123; if(s.length() == 1 || s.length() == 0) return s; int max = 1; int ans; String result = "" +s.charAt(0); for(int i=1;i&lt;s.length();i++)&#123; ans = Math.max(PS_length(s, i-1, i+1), PS_length(s, i-1, i)); if(ans &gt; max)&#123; max = ans; if(ans % 2 == 0) result = s.substring(i-ans/2, i+ans/2); else result = s.substring(i-ans/2, i+ans/2+1); &#125; &#125; return result; &#125; //PS is short for Palindromic Substring public int PS_length(String s, int i, int j)&#123; while(i &gt;=0 &amp;&amp; j &lt; s.length())&#123; if(s.charAt(i)!=s.charAt(j)) break; --i; ++j; &#125; return j-i-1; //return (j-i-1)+2 &#125; &#125; 小trick：在求子串时，下标可以通过实例来明确。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[回车符与换行符]]></title>
      <url>http://blade6.top/posts/285ba2a7/</url>
      <content type="text"><![CDATA[昨天晚上做NLP的时候，需要对文件做一些预处理。然后无意中发现一点小问题。通过用python和java分别对文件进行输出文本行数，发现不同。输入文本文件:199801.txt下面是Java实现的代码：12345678910111213141516171819202122232425import java.io.*;import java.util.*;public class test &#123; public static void main(String[] args) throws FileNotFoundException &#123; java.io.File in_file = new java.io.File("199801.txt"); Scanner input = new Scanner(in_file); java.io.File out_file = new java.io.File("test.txt"); java.io.PrintWriter output = new java.io.PrintWriter(out_file); //p_num表示文本总行数，q_num表示存在有效文字的行数 int p_num = 0,q_num = 0; while(input.hasNextLine())&#123; String line = input.nextLine(); ++p_num; if("".equals(line))&#123; continue; &#125; ++q_num; output.println(q_num+" "+line); &#125; System.out.println(p_num+" "+q_num); input.close(); output.close(); System.out.println("Done!"); &#125;&#125; 控制台上输出：23064 19484Done!用Python实现的情况如下：1234567891011121314151617181920f = open('199801.txt','r')g = open('test1.txt','w')p_num = 0q_num = 0while True: line = f.readline() if len(line): p_num += 1 if line != '\n': continue q_num += 1 g.write(str(q_num)+" "+line) else: breakf.close()g.close()print p_num,q_num 控制台输出：22722 19538 可以观察到总行数Java这边较大，有效行数Python这边较大。我决定首先解决有效行数不一致的问题。因为我在代码中还写了把有效行写成文件的内容，所以我决定检查一下test.txt和text1.txt文件有什么不同。手动打开两个文件，通过粗略估计+二分搜索法，确定第一次输出不同在第341行。(P.S.有效行是指该行中存在文字。)text.txt line341: 341 19980101-07-007-001/m 细语/n （/w 中国画/n ）/w tex1.txt line341: 341 也就是text1.txt的341行实际上不是有效行，说明Python代码中判断是否是有效行的逻辑有错误。于是我认为输入的文本文件中可能混有回车符和换行符。（P.S.这里考虑到文章的整体的流畅性，省略了很多细节。实际上最初我认为问题出在Java，因为我引入了C++语言，统计文本行数的结果和Python是一致的。当时我认为问题出在Java代码中的input.nextLine()处，所以搜索了很多关于这个函数返回值的问题，知道了nextLine()会吞掉换行符。然后通过百度换行符，我又了解到了回车符这个概念，其实以前学过，忘记了。。）于是我对Python代码稍加修改，增加在原代码13行和14行之间:1234if q_num == 341: print len(line) if line == '\r\n': print 'bingo' 控制台显示： 2bingo22722 19538 于是判断出问题的关键在于’\r’和’\n’。于是我对Python代码进行了再次修改：1234567891011121314151617181920f = open('199801.txt','r')g = open('test1.txt','w')p_num = 0q_num = 0while True: line = f.readline() if len(line): p_num += 1 if line == '\n' or line == '\r\n' or line == '\r': continue q_num += 1 g.write(str(q_num)+" "+line) else: breakf.close()g.close()print p_num,q_num 再执行了一遍，控制台输出： 22722 19485 为什么有效行数仍然多了一行？首先需要找出有问题的行，于是我写了一段Python代码，避免手工排查：（P.S.其实第一次手工排查前我就尝试写脚本排查，无奈因为不知道回车符，导致没有写出有效的脚本）123456789101112131415161718192021f = open('test1.txt','r')g = open('D:\\java\\Dev\\test.txt','r')num = 0while True: line1 = f.readline() line2 = g.readline() num += 1 if line1 != line2: if len(line1) == len(line2)+1: continue else: break if not len(line1): breakprint num,len(line1),len(line2)f.close()g.close() 因为text1.txt有些行有\r，所以有些行的长度会比text.txt中的对应行大1，但实际上有效内容是一致的，所以代码中进行了忽略这样的行。执行后控制台输出： 1265 8 77 可以看到两个文件是在第1265行出现分歧的。有了之前的经验教训，我怀疑text1.txt的1265行的内容是”1265 \r\r\n”，通过对脚本的代码稍加修改：12345678910111213141516171819202122232425f = open('test1.txt','r')g = open('D:\\java\\Dev\\test.txt','r')num = 0while True: line1 = f.readline() line2 = g.readline() num += 1 if line1 != line2: if len(line1) == len(line2)+1: continue else: if num == 1265: print len(line1) if line1 == "1265 \r\r\n": print 'bingo' break if not len(line1): breakprint num,len(line1),len(line2)f.close()g.close() 控制台输出： 8bingo1265 8 77 证明我的判断是正确的。至此，解决了有效行数不一致的问题。那么为什么总行数会不相等呢？实际上，Python中f.readline()返回一行，不对这行做任何处理。而Java中input.nextLine()会获取从当前位置开始到一个结束符前的内容，然后去掉末尾的结束符返回。通过对本文Java代码稍加改写，可以发现’\r’，’\n’都会被认为是结束符。比如：当文本中有一行的内容为”\r\n”时，f.readline()会返回”\r\n”，行数加1。input.nextLine()返回”\r”前的内容，也就是””，行数加1；然后input.nextLine()会返回”\n”前的内容，也是””，行数加1。读取这一行后，Java和Python的行数就出现不一致了。 综上，对于Java中的Scanner的nextLine()方法，其名字中的nextline并不是真正意义上的下一行，准确地说应该是从当前位置到下一个结束符之前的内容。Python的readline()方法返回真正意义上的一行，所以在对行做处理时，需要考虑行末是换行符或回车+换行符的情况。 附上回车符与换行符的区别： CR：CarriageReturn，回车符，用’\r’表示，16进制代码为0x0D，光标移动到当前行的最左边。LF：LineFeed，换行符，用’\n’表示，16进制代码为0x0A，把光标向下移动一行。 不同操作系统表示一行的结束不同：Unix、Linux：\n表示回车+换行，\r无意义Windows、DOS：\r\n表示回车+换行，顺序不能颠倒Mac：\r表示回车+换行(P.S.Mac OS 9以及之前的系统的换行符是CR，从Mac OS X（后来改名为OS X）开始的换行符是LF，和Unix/Linux统一了。) 影响：（1）一个直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；（2）而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。（3）Linux保存的文件在windows上用记事本看的话会出现黑点。 相互转换：在linux下，命令unix2dos 是把linux文件格式转换成windows文件格式，命令dos2unix 是把windows格式转换成linux文件格式。 在不同平台间使用FTP软件传送文件时, 在ascii文本模式传输模式下, 一些FTP客户端程序会自动对换行格式进行转换. 经过这种传输的文件字节数可能会发生变化.如果你不想ftp修改原文件, 可以使用bin模式(二进制模式)传输文本。一个程序在windows上运行就生成CR/LF换行格式的文本文件，而在Linux上运行就生成LF格式换行的文本文件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Hexo搭建个人博客小记]]></title>
      <url>http://blade6.top/posts/21637/</url>
      <content type="text"><![CDATA[今天购买了域名，基本上完成了博客的各项配置，接下来就可以开始写博客了。因为目前暂时没有什么干货，只好把建站的一些过程发上来撑撑场面，~_~ 动机其实在今年年初的时候，师兄就让我们搭建自己的博客。那个时候的我，完全0基础。硬是一个寒假在虚拟机上搭建了一个博客，那个时候只是把它当成作业来完成的，做得十分简陋，这里就不po上来献丑了。做好之后就搁置了。直到这个学期，前几周，计算机英语老师说计算机专业的学生怎么能没有自己的个人网站，于是我萌生了搭建博客网站的想法。因为现在Nodejs+Hexo+Github Pages搭建博客很流行，于是我也加入了这股潮流。说干就干，网上的资料十分多，可能是每个搭建博客的都写了一篇建站日志, : ) 建站大致过程 安装Git Bash,Nodejs,Hexo. GitHub新建repo，并设置SSH. 下载安装next主题，并按照NexT的内容进行各项参数的设置。 多说评论、分享、热评文章 LeanCloud阅读次数统计 Local Search 购买域名。 SEO推广 文章链接唯一永久化 更改阅读全文样式打开\themes\next\source\css\_common\components\post\post-button.styl文件，修改成1234567891011121314151617181920212223242526.post-button &#123; margin-top: 50px; .btn &#123; display: inline-block; border-width: 2px; border-style: solid; border-color: rgb(85,85,85); padding: 0 20px; line-height: 2; font-size: 14px; color: #555555; text-decoration: none; &#125; .btn:hover &#123; color: white; background-color: #222222; &#125;&#125; 参考资料如何使用10个小时搭建出个人域名而又Geek的独立博客使用Hexo搭建个人博客(基于hexo3.0)Hexo系列教程Hexo+nexT主题搭建个人博客使用Hexo搭建博客的深度优化将hexo博客同时托管到github和codinghexo提交搜索引擎 在此致谢所有无形中帮助到我的人，谢谢你们的分享。互联网精神万岁！]]></content>
    </entry>

    
  
  
</search>
