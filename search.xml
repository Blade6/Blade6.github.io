<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[指令重排]]></title>
      <url>http://blade6.top/posts/c12d9bbd/</url>
      <content type="text"><![CDATA[节选自《实战Java高并发程序设计》，有删改 为什么要指令重排呢？让他一步一步执行多好呀！也不会那么多奇葩的问题。 之所以这么做，完全是因为性能考虑。我们知道，一条指令的执行时可以分为很多步骤的。简单地说，可以分为以下几步： 取指 IF 译码和取寄存器操作数 ID 执行或者有效地址计算 EX 存储器访问MEM 写回WB 由于每一个步骤都可能使用不同的硬件完成，因此，聪明的工程师们就发明了流水线技术来执行指令，如图1所示，显示了流水线的工作原理。 可以看到，当第2条指令执行时，第1条指令其实并未执行完，确切地说第1条指令还没开始执行，只是刚刚完成了取值操作而已。这样的好处非常明显，假如这里每一个步骤都需要花费1毫秒，那么指令2等待指令1完全执行后，再执行，则需要等待5毫秒，而使用流水线后，指令2只需要等待1毫秒就可以执行了。如此大的性能提升，当然让人眼红。更何况，实际的商业CPU的流水线级别甚至可以达到10级以上，则性能提升就更加明显。 而流水线总是害怕被中断，因为一旦中断，所有的硬件设备都会进入一个停顿期，再次满载又需要几个周期，因此，性能损失会比较大。而指令重排，就是为了减少中断而使用的技术。 让我们来看一个具体例子。图2展示了A=B+C这个操作的执行过程。写在左边的指令就是汇编指令。LW R1,B表示把B的值加载到R1寄存器中。ADD R3,R1,R2表示把R1、R2的值相加，并存放到R3中。SW A,R3表示把R3寄存器的值保存到变量A中。 注意，在ADD指令上，有一个间隔，表示一个中断。为什么会中断？原因很简单，R2的数据还没有准备好。所以，ADD操作必须进行一次等待。由于ADD的延迟，导致其后面所有的指令都要慢一个节拍。 理解了上面这个例子，我们就可以来看一个更加复杂的情况。a=b+cd=e-f上述代码的执行如图3所示。 由于ADD和SUB都需要等待上一条指令的结果，因此，在这里插入了不少停顿。那么对于这段代码，是否有可能消除这些停顿呢？显然是可以的。我们只需要将LW Re,e和LW Rf,f移动到前面执行即可。思想很简单，先加载e和f对程序是没有影响的。既然在ADD的时候一定要停顿一下，那么停顿的时间还不如去做点有意义的事情。重排后的结果如图4所示。可以看到，所有的停顿都已经消除，流水线已经可以十分顺畅地执行。 由此可见，指令重排对于提高CPU处理性能是十分必要的。虽然确实带来了乱序的问题，但是这点牺牲是完全值得的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Roman to Integer]]></title>
      <url>http://blade6.top/posts/9799a86c/</url>
      <content type="text"><![CDATA[罗马数字转整数。首先需要知道罗马数字的表示，百度一下就能找到。然后我首先想到了用HashMap把罗马符号和它对应的数字存起来，方便之后取用。于是写出了第一个程序：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public int romanToInt(String s) &#123; String[] signs = new String[]&#123; "I","II","III","IV","V","VI","VII","VIII","IX", "X","XX","XXX","XL","L","LX","LXX","LXXX","XC", "C","CC","CCC","CD","D","DC","DCC","DCCC","CM", "M","MM","MMM"&#125;; int[] number = new int[]&#123; 1,2,3,4,5,6,7,8,9, 10,20,30,40,50,60,70,80,90, 100,200,300,400,500,600,700,800,900, 1000,2000,3000 &#125;; HashMap&lt;String, Integer&gt; num = new HashMap&lt;&gt;(); for (int i = 0; i &lt; signs.length; i++) &#123; num.put(signs[i], number[i]); &#125; int length = s.length(); int result = 0; for (int i = 0; i &lt; length;) &#123; if (length - i &gt;= 4) &#123; if (num.containsKey(s.substring(i, i + 4))) &#123; result += num.get(s.substring(i, i + 4)); i += 4; continue; &#125; &#125; if (length - i &gt;= 3) &#123; if (num.containsKey(s.substring(i, i + 3))) &#123; result += num.get(s.substring(i, i + 3)); i += 3; continue; &#125; &#125; if (length - i &gt;= 2) &#123; if (num.containsKey(s.substring(i, i + 2))) &#123; result += num.get(s.substring(i, i + 2)); i += 2; continue; &#125; &#125; result += num.get(s.substring(i, i + 1)); ++i; &#125; return result;&#125; 提交后虽然AC了，但是排名12%还是不太满意。仔细看看程序，发现可以优化，VIII实际上只需要存V和I就行了，并不需要单独存储。这样一来，程序可以简化如下：12345678910111213141516171819202122232425262728293031323334public int romanToInt(String s) &#123; int result = 0; String[] signs = new String[]&#123; "I","IV","V","VI","IX", "X","XL","L","LX","XC", "C","CD","D","DC","CM", "M"&#125;; int[] number = new int[]&#123; 1,4,5,6,9, 10,40,50,60,90, 100,400,500,600,900, 1000 &#125;; HashMap&lt;String, Integer&gt; num = new HashMap&lt;&gt;(); for (int i = 0; i &lt; signs.length; i++) num.put(signs[i], number[i]); for (int i = 0; i &lt; s.length();) &#123; if (i + 1 &lt; s.length()) &#123; if (num.containsKey(s.substring(i, i+2))) &#123; result += num.get(s.substring(i, i+2)); i += 2; &#125; else &#123; result += num.get(s.substring(i, i+1)); ++i; &#125; &#125; else &#123; result += num.get(s.substring(i, i+1)); break; &#125; &#125; return result;&#125; 提交后当然也AC了，排名42%了。但是程序似乎还可以优化，比如VI不需要单独存储，因为VI可以通过V和I得到，但是如果去掉了VI、LX、DC的话，程序的执行速度是变慢的，理由很简单，因为nums.containsKey(s.substring(i,i+2))反正都要判断目前的两个字符，何必要多此一举把两个字符拆开走下面的else，这样实际上是浪费了效率。 除了上面的方法外，我还想到了另一种方法，代码如下：1234567891011121314151617181920212223242526272829303132333435363738public int romanToInt(String s) &#123; int result = 0; char[] array = s.toCharArray(); for (int i =0 ; i &lt; array.length; i++) &#123; switch (array[i]) &#123; case 'I': result += 1; break; case 'V': if (i &gt; 0 &amp;&amp; array[i-1] == 'I') result += 3; else result += 5; break; case 'X': if (i &gt; 0 &amp;&amp; array[i-1] == 'I') result += 8; else result += 10; break; case 'L': if (i &gt; 0 &amp;&amp; array[i-1] == 'X') result += 30; else result += 50; break; case 'C': if (i &gt; 0 &amp;&amp; array[i-1] == 'X') result += 80; else result += 100; break; case 'D': if (i &gt; 0 &amp;&amp; array[i-1] == 'C') result += 300; else result += 500; break; case 'M': if (i &gt; 0 &amp;&amp; array[i-1] == 'C') result += 800; else result += 1000; break; &#125; &#125; return result;&#125; 不过表现不太出色，排名26%左右。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[String to Integer(atoi)]]></title>
      <url>http://blade6.top/posts/ecbf921f/</url>
      <content type="text"><![CDATA[把字符串转整数。这是一道考察代码健壮性的题目。当我第一次写好代码以为自己很厉害时，现实很快就狠狠地打脸。我觉得代码之所以没写好，主要是想象力不够。总是有些脑回路特殊的人写出一些出乎意料的TestCase，真够变态的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public int myAtoi(String str) &#123; // 处理字符串包含空格的情况，比如" 010" str = str.trim(); if (str == null || str.length() == 0) return 0; if (str.length() == 1) &#123; if (!Character.isDigit(str.charAt(0))) return 0; return str.charAt(0) - '0'; &#125; char[] array = str.toCharArray(); // 默认为正数 boolean flag = true; int ans = 0; int index = 0; if (array[0] == '-') &#123; if (Character.isDigit(array[1])) &#123; ans = - (array[1] - '0'); flag = false; index = 2; &#125; &#125; else if (array[0] == '+') &#123; index = 1; &#125; for (; index &lt; array.length ; index++) &#123; if (Character.isDigit(array[index])) &#123; if (ans * 10 / 10 != ans) &#123; if (flag) return Integer.MAX_VALUE; else return Integer.MIN_VALUE; &#125; else ans *= 10; //System.out.println("ans: " + ans); if (flag) ans += array[index] - '0'; else ans -= array[index] - '0'; // 当为正数时，结果却为负数，说明溢出了，返回最大正整数 if (ans == Integer.MIN_VALUE &amp;&amp; flag) return Integer.MAX_VALUE; // 与上述正相反 if (ans == Integer.MAX_VALUE &amp;&amp; !flag) return Integer.MIN_VALUE; //System.out.println("ans: " + ans); &#125; else return ans; &#125; if (index == array.length) return ans; else return 0;&#125; 写出来的代码虽然AC了，但是惨不忍睹，也不便于维护。看了看leetcode大神们写的简洁的代码，每一步都是如此地恰到好处，完美地演绎Just Enough的哲学。而我等小白，路还很长。 走过的坑(TestCases)：“hello”,“15”,“-2147483647”,“01234”,“2147483648”,“3333333333”,“he123”,“+444”,“-2147483649”,“-“,“-3333333333”,“ 010”,“01 12”,“ 12 “,“ +004500”,“123hehe”,“ - 12”]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Add Two Numbers]]></title>
      <url>http://blade6.top/posts/64c8f80f/</url>
      <content type="text"><![CDATA[给定两个非空链表，计算这两个链表所代表的数字的和。比如2-&gt;3-&gt;4和3-&gt;1-&gt;7表示的数字是432和713，需要求出和1145并返回链表5-&gt;4-&gt;1-&gt;1。 解题思路对于两个链表都从左往右进行扫描，相加，注意处理边界条件（两个链表一长一短）和进位情况，算法时间复杂度为O(N)。 解法一具体描述l1指向链表1的当前结点，l2指向链表2的当前结点，l3指向结果链表的当前结点，result指向结果链表的头结点。用c表示进位情况，有进位时c为1。初始时，因为l1和l2都非空，将二者的值之和赋给l3，同时根据进位情况更改c的值。首先循环判断l1的下一个结点是否非空，若非空，令l1指向下一个结点，同时l3也指向新结点（用0创建）。判断l2的下一个结点是否非空，来决定是把l1的值赋给l3还是把两链表结点值之和赋给l3，不要忘了进位情况。循环结束条件为l1所在链表没有更多结点了。然后循环循环判断l2的下一个结点是否非空，此循环在链表1的长度比链表2的要短时有效。把链表2的剩余结点的值逐个赋给结果链表。不要遗漏最后一个结点有进位的情况。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode l3 = new ListNode(0); ListNode result = l3; int c = 0; if(l1.val+l2.val&lt;10) l3.val = l1.val+l2.val; else&#123; l3.val = l1.val + l2.val - 10; c = 1; &#125; while(l1.next != null)&#123; l1 = l1.next; l3.next = new ListNode(0); l3 = l3.next; if(l2.next != null)&#123; l2 = l2.next; if(l1.val+l2.val+c&lt;10)&#123; l3.val = l1.val+l2.val+c; if(c==1) c=0; &#125;else&#123; l3.val = l1.val + l2.val + c - 10; c = 1; &#125; &#125;else&#123; if(l1.val + c &lt; 10)&#123; l3.val = l1.val + c; if(c==1) c=0; &#125;else&#123; l3.val = l1.val + c - 10; c = 1; &#125; &#125; &#125; while(l2.next != null)&#123; l2 = l2.next; l3.next = new ListNode(0); l3 = l3.next; if(l2.val + c &lt; 10)&#123; l3.val = l2.val + c; if(c==1) c=0; &#125;else&#123; l3.val = l2.val + c - 10; c = 1; &#125; &#125; if(c==1)&#123; l3.next = new ListNode(1); &#125; return result; &#125;&#125; 提交后AC通过，运行时间57ms，排名59%。这个代码的缺点是每次都用0去初始化新结点，然后再修改新结点的值，造成时间浪费。同时整体结构不够精简，有比较多的重复代码，不能让人一眼明白程序在做什么。 解法二具体描述详见代码，代码是在观摩了众大神的代码后，稍微润色了一下，非常地简单优雅，一目了然。第29行return result.next;干得漂亮！ 代码1234567891011121314151617181920212223public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode l3 = new ListNode(0); ListNode result = l3; int sum = 0; int carry = 0; while (l1 != null || l2 != null || carry != 0) &#123; sum = carry; if (l1 != null) &#123; sum += l1.val; l1 = l1.next; &#125; if (l2 != null) &#123; sum += l2.val; l2 = l2.next; &#125; carry = sum / 10; l3.next = sum &lt; 10 ? new ListNode(sum) : new ListNode(sum - 10); l3 = l3.next; &#125; return result.next; &#125;&#125; 提交后AC，运行时间51ms，排名91%。P.S.代码运行速度每减少1ms，幸福度增加10%。P.S.S 其实我一开始写的代码略微有点不同，第18行写的是l3.next = new ListNode(sum % 10);，但是提交后提示超时，不知道leetcode搞什么飞机，没办法，我觉得代码是对的，又不想做修改，只好稍微修改敷衍一下。 帮助自己在本地编写代码调试时，可以对ListNode进行扩展，方便调试代码。 ListNode1234567891011121314151617181920212223242526public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; // 打印ListNode的每个值 public static void print (ListNode temp) &#123; while (temp != null) &#123; System.out.print(temp.val + "-&gt;"); temp = temp.next; &#125; System.out.println(); &#125; // 根据整数数组创建ListNode public static ListNode create (int[] nums) &#123; ListNode result = new ListNode(0); ListNode index = result; for (int num : nums) &#123; ListNode cur = new ListNode(num); index.next = cur; index = index.next; &#125; return result.next; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Longest Substring Without Repeating Characters]]></title>
      <url>http://blade6.top/posts/8e8877f3/</url>
      <content type="text"><![CDATA[给定字符串，求出它的不重复最长子串的长度。以下提供两种方法，时间复杂度都是O(N)级别，但因为O(N)只是描述了一个上界，而且是很模糊的，所以以下两个算法的真实运行时间还是有差异的。不过以下两个算法在本质上都是一样的，读者通读代码后不难发现这一点。 方法一解题思路对于字符串s，用指针i从左往右顺序扫描该字符串，用temp记录当前的子字符串。当i所指向的字符未在temp中出现时，则temp加上i所指向的字符，同时i右移一位。当i所指向的字符x已经出现了时，判断temp的长度和最大值max，以决定是否将temp的长度赋给max。则temp应自行截断从起点到x为止的字符串，然后temp的剩余部分加上i所指向的字符构成新的temp，同时i右移一位。需要注意的是整个循环结束后，仍然要判断temp的长度和max的大小，因为循环体会漏掉最后一次判断。 代码1234567891011121314151617181920212223public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if(s.length()==0) return 0; else if(s.length()==1) return 1; int max = 0; String temp = "" + s.charAt(0); int i = 1; while(i&lt;s.length())&#123; if(temp.indexOf(s.charAt(i)) &gt;= 0)&#123; if(temp.length() &gt; max) max = temp.length(); int index = temp.indexOf(s.charAt(i)) + 1; temp = temp.substring(index) + s.charAt(i); ++i; &#125; else&#123; temp += s.charAt(i); ++i; &#125; &#125; if(temp.length() &gt; max) max = temp.length(); return max; &#125;&#125; 此处贴的是AC了的代码，期间失败多次，不一一详述。运行速度排名47%。 方法二解题思路对于字符串s，把它转化为字符数组str，数组可以随机存取，可以加快存取速度，str的每个元素都是一个字符。因为C语言中char的范围是-128~127，所以可以肯定TestCase的字符都是在这个范围里面的。所以虽然我是用Java写的，但是我仍然使用了一个布尔值的数组exist，长度为256，判断每个字符是否已经存在于子字符串中。初始时令head指向str的第1个元素，tail指向str的第2个元素，同时将exist[str[0]]置为true，表示str的第1个元素在子字符串中已出现，所谓子字符串，指的是str的下标head到tail的区域的字符组合。然后tail不断右移。对于tail指向的元素，如果未在子字符串中出现，那么将tail指向的元素标记为已出现，同时tail右移一位。如果tail指向的元素已经在子字符串中出现了，那么head不断右移，在右移的过程中，每右移一位表示将一个元素踢出子字符串，这时要把踢出去的元素标记为未出现，因为已经被踢出去了，子字符串中不包含该元素了。右移的结束条件是将和tail指向的元素相同的元素踢出子字符串，这时head指向这个被踢出元素的下一个位置，同时tail指向下一个位置，不需要将最后踢出的元素标记为未出现，因为最后踢出的元素和加入的元素是同一个元素。需要注意的地方和方法一相同，都是在循环的过程中会遗漏最后一次比较。 代码123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if (s.length() == 0 || s.length() == 1) return s.length(); char[] str = s.toCharArray(); //存在数组 boolean[] exist = new boolean[256]; //记录最大值 int max = 1; //头指针和尾指针 int head = 0, tail = 1; exist[str[0]] = true; while (tail &lt; str.length) &#123; if (exist[str[tail]]) &#123; if (tail - head &gt; max) max = tail - head; //头指针要指向与尾指针相同字符的下一个位置 //比如"abcdcef" //当tail指向第2个c时，head要指向d while (head &lt; tail) &#123; if (str[head] == str[tail]) &#123; ++head; ++tail; break; &#125; else &#123; exist[str[head]] = false; ++head; &#125; &#125; &#125; else &#123; exist[str[tail]] = true; ++tail; &#125; &#125; if (tail -head &gt; max) max = tail - head; return max; &#125;&#125; 提交后AC，运行速度排名99%。 测试代码用于测试算法是否正确，包含一些典型的TestCase。1234567891011public class Test &#123; public static void main(String[] args) &#123; Solution demo = new Solution(); String[] test = new String[]&#123;"abcabcbb", "bbbbb", "pwwkew", "au", "c", "dvdf", "", "bab", "abcdbef", "abcdcef"&#125;; for (String s : test) System.out.println(s + ":" + demo.lengthOfLongestSubstring(s)); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Maximum Subarray]]></title>
      <url>http://blade6.top/posts/b8913e5e/</url>
      <content type="text"><![CDATA[给定数组，求数组中的所有子串中最大的子串和。很容易就能想到O(n^3)的算法，一个一个遍历，但一定会超时的。下面介绍两种方法，第一种的时间复杂度为O(NlogN)，但是仍然超时，第二种为O(N)。 分治法解题思路对于给定数组，可以把该数组分成两部分，左半部分和右半部分。对于该数组的最大的子串和，要么出现在左半部分，要么出现在右半部分，要么出现在左半部分和右半部分的交叉部分。对于交叉部分，一定是从中间向两侧扩散的，写代码的时候要注意这一点。 代码如下1234567891011121314151617181920212223242526272829public class Solution &#123; public int maxSubArray(int[] nums) &#123; return maxSum(nums, 0, nums.length-1); &#125; public int maxSum(int[] nums, int left, int right) &#123; if (left == right) return nums[left]; int center = (left + right) / 2; int maxLeft = maxSum(nums, left, center); int maxRight = maxSum(nums, center+1, right); int maxLeftBorder = nums[center], leftBorder = nums[center]; for (int i = center-1; i &gt;= left; i--) &#123; leftBorder += nums[i]; if (leftBorder &gt; maxLeftBorder) maxLeftBorder = leftBorder; &#125; int maxRightBorder = nums[center+1], rightBorder = nums[center+1]; for (int j = center+2; j &lt;= right; j++) &#123; rightBorder += nums[j]; if (rightBorder &gt; maxRightBorder) maxRightBorder = rightBorder; &#125; return Math.max(Math.max(maxLeft, maxRight), maxLeftBorder+maxRightBorder); &#125;&#125; 循环的结束条件只判断了left==right的情况，left&gt;right的情况是不会出现的，利用反证法可以轻易证明，此处不展开叙述。 但是提交后仍然超时了。善良的leetcode在结果页面上告诉了我202个Testcase都通过了，代码本身是正确的，只是用时过长。 一次扫描法解题思路因为leetcode对题目做了限定，返回的最大子串和所在的子串至少包含一个数，换言之数组中所有数都是负数的情况下，最大子串和必然是最大的那个负数，这就是情况1。情况2：当所有数都是非负数，最大子串和就是数组中所有数的和。情况3：当输入的数组有正数有负数时，令max=0，temp=0，max表示最大子串和，因为数组中有正数，所以max的值会在循环中被改变，不会一直保持为0。temp表示当前的子串和。令指针i初始时指向数组第一个元素，i每次向后移动一位。对于i当前指向的元素，把它加到temp里。然后判断temp和max的大小，决定是否把temp的值赋给max。如果temp&lt;max时，还要判断temp的值是否小于0，如果小于0，则temp=0，表示舍弃temp所表示的子串，从该子串的下一个数开始求最大子串和，此处可以用反证法证明如下：若temp表示从下标m到n的子串和，假设我们最终求得的最大子串和MAX是从下标m到n+p的子串的和。那么MAX=temp+nums[n+1]+...+nums[n+p]，而又因为temp&lt;0，则存在REAL_MAX=nums[n+1]+...+nums[n+p]&gt;MAX，这与假设矛盾。 情况2和情况3可以一起处理，情况1需要特殊处理。 代码123456789101112131415161718192021222324public class Solution &#123; public int maxSubArray(int[] nums) &#123; int max = 0, temp = 0; boolean flag = false; for (int i = 0; i &lt; nums.length; i++) &#123; temp += nums[i]; if (temp &gt; max) max = temp; else if (temp &lt; 0) temp = 0; //如果数组中存在非负数，且flag为false的话， //flag置为true表示数组中存在非负数 if (!flag &amp;&amp; nums[i] &gt;= 0) flag = true; &#125; if (flag) return max; else &#123; int N_max = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i] &gt; N_max) N_max = nums[i]; &#125; return N_max; &#125; &#125;&#125; 提交后代码AC了，运行速度排名在67%左右。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Generate Parentheses]]></title>
      <url>http://blade6.top/posts/c59bb016/</url>
      <content type="text"><![CDATA[给定n，求n对括号可以生成的括号嵌套种数。这道题其实不难，很快就能想出解题思路。 解题思路对于n，记录的是括号的数目，本质上也是左括号和右括号的出现次数。假设t记录左括号的剩余出现次数，cur记录当前未匹配的左括号个数，str记录单次结果，str的长度是固定的，必然是2n。首先要初始化：t=n，cur=0，str=””。当循环开始时，第1个符号必须是左括号，然后t-=1，表示左括号的剩余出现次数变成n-1了。同时str+=”(“，cur+=1，表示str中有1个左括号未匹配。对于第i个符号：如果t==0且cur==0，说明循环结束，将str加到结果集中。如果t==0，说明左括号的剩余出现次数已用完，那么第i个符号只能取右括号，同时cur-=1；如果cur==0，说明str中不存在未匹配的左括号，那么第i个符号只能取左括号，同时t-=1；如果t&gt;0且cur&gt;0，则第i个符号可以是左括号也可以是右括号，如果第i个符号取左括号，那么t-=1，cur+=1，如果第i个符号取右括号，那么cur-=1。注意：因为对于第i个符号，当t&gt;0且cur&gt;0的时候，第i个符号可以有两种取值，所以使用递归会取得事半功倍的效果。 代码1234567891011121314151617181920public class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; l = new ArrayList&lt;String&gt;(); test(l, n, 0, ""); return l; &#125; public void test(List&lt;String&gt; l, int t, int cur, String str)&#123; if(t==0 &amp;&amp; cur == 0)&#123; l.add(str); &#125;else if(cur == 0)&#123; test(l, t-1, cur+1, str+"("); &#125;else if(t==0)&#123; test(l, t, cur-1, str+")"); &#125;else&#123; test(l, t-1, cur+1, str+"("); test(l, t, cur-1, str+")"); &#125; &#125;&#125; 一次AC通过，运行速度排名39%。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Merge Two Sorted Lists]]></title>
      <url>http://blade6.top/posts/a72883c7/</url>
      <content type="text"><![CDATA[合并两个有序链表。因为是链表，所以可以写出空间复杂度为O(1)的算法。 解题思路对于这两条链表，给定指针l1和l2，分别指向两条链表的结点。给定指针result，指向结果链表的尾结点。每次比较l1指向结点和l2指向结点的值的大小，然后把小的那个结点插入到结果链表的尾部，同时使存储该结点的指针指向其下一个结点，结果链表的指针result指向下一个结点。注意result每次都指向结果链表的尾结点，而不是尾结点的next部，否则会导致空指针错误。操作如图：橙色为上一步，蓝色为下一步。 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1 == null) return l2; if(l2 == null) return l1; //对于两个链表的第一个结点的比较单独写出来， //因为需要初始化result_head，result_head指向结果链表的第一个结点 ListNode result = null; if(l1.val &lt;= l2.val) &#123; result = l1; l1 = l1.next; &#125; else &#123; result = l2; l2 = l2.next; &#125; ListNode result_head = result; while(true) &#123; if(l1 == null) &#123; result.next = l2; break; &#125; else if (l2 == null) &#123; result.next = l1; break; &#125; else &#123; if(l1.val &lt;= l2.val) &#123; result.next = l1; l1 = l1.next; &#125; else &#123; result.next = l2; l2 = l2.next; &#125; result = result.next; &#125; &#125; return result_head; &#125; &#125; 提交后AC，运行速度排名60%左右。 还可以使用分治法，可以写出简短易懂的代码。1234567891011121314public class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1 == null) return l2; if(l2 == null) return l1; if(l1.val &lt;= l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Pow(x,n)]]></title>
      <url>http://blade6.top/posts/bbe3cb45/</url>
      <content type="text"><![CDATA[这道题是实现内置函数pow(x,n)。思路没什么复杂的，我很快就想出了第一个答案：123456789101112131415161718public class Solution &#123; public double myPow(double x, int n) &#123; if (n == 0) return 1.0; if (n == 1) return x; int m = n; if(n &lt; 0) m = -n; double result = x; while(m &gt; 1) &#123; result *= x; --m; &#125; if(n &lt; 0) return 1 / result; return result; &#125;&#125; 然后也很快地死在以下TestCase：0.000012147483647死亡原因：超时。 超时的原因很简单，我的算法是一个O(n)级别的算法。而事实上存在O(log n)级别的算法。所以，分治法出场了。 解题思想对于x^n，通常可以这样做：如果n是奇数，那么x^n等价于(x*x)^(n/2)*x;如果n是偶数，那么x^n等价于(x*x)^(n/2). 有了思想，很快就写出了代码：123456789101112131415public class Solution &#123; public double myPow(double x, int n) &#123; if(n == 0) return 1.0; if(n == 1) return x; if(n &lt; 0) return 1 / My_pow(x, -n); else return My_pow(x, n); &#125; public double My_pow(double x, int m) &#123; if(m == 1) return x; if(m % 2 == 0) return My_pow(x*x, m/2); return My_pow(x*x, m/2) * x; &#125;&#125; 提交后死在以下TestCase上：1.00000-2147483648死亡原因：运行时错误（栈溢出）P.S.仔细一看，就能发现错误。但当时我没有意识到。后来我修改了My_pow()方法，在第一行加上了if (m == 0) return 1.0;，提交后就AC了，运行速度排名70%左右。 当时看到栈溢出的错误时，我第一感觉是使用了递归导致的，于是试图实现使用循环代替递归，但是以失败告终。经过在网上搜索，对比别人的代码，我修改代码如下：1234567891011121314151617public class Solution &#123; public double myPow(double x, int n) &#123; if(n == 0) return 1.0; if(n == 1) return x; if(n == Integer.MIN_VALUE) return 1 / (My_pow(x, Integer.MAX_VALUE) * x); if(n &lt; 0) return 1 / My_pow(x, -n); else return My_pow(x, n); &#125; public double My_pow(double x, int m) &#123; if(m == 0) return 1.0; if(m == 1) return x; double half = My_pow(x, m/2); return half * half * My_pow(x, m%2); &#125;&#125; 提交后AC了，运行速度排名44%。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ZigZag Conversion]]></title>
      <url>http://blade6.top/posts/6d08e17c/</url>
      <content type="text"><![CDATA[一开始看到题目的时候，我是搞不清楚情况的。主要原因是不明白ZigZag的意思。 ZigZag比如有数字序列0,1,2,3，…，12，按照ZigZag排序如下：1230 4 8 121 3 5 7 9 112 6 10 ZigZag的含义就是锯齿形的，之字形的，Z字形的。现在问题明白了，给定字符串s和行数numRows，把字符串按照ZigZag排列，然后逐行按列读取，形成一个新的字符串，返回这个字符串。 解题思路这道题其实就是找规律。找到规律，代码写起来也很快。那么规律是什么呢？通过实例来捋一捋：对于给定的字符串s，它的每一个字符都应该有一个下标，这样就会形成一个下标序列，从0到s.length()-1。假设我们现在有0到20这21个数，是某个字符窜的下标序列。如果给定的numRows=6，那么把这个字符串按照ZigZag排列应该如下：1234560 10 201 9 11 192 8 12 183 7 13 174 6 14 165 15 规律如下：对于每一行的首个元素，其实是很好确定的，就是从0到numRows-1;对于首行和末行，每一个数都恰好是其前一个数加上2numRows-2;对于中间行，分成奇数位元素和偶数位元素处理，对于奇数位元素，每一个数都恰好是其前一个数加上2numRows-2，偶数位元素也是如此。 思路捋顺了，规律找到了，我们开始写代码：123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; public String convert(String s, int numRows) &#123; int length = s.length(); if (length == 1 || numRows == 1 || numRows &gt;= length) return s; StringBuilder result = new StringBuilder(); for (int i = 0; i &lt; numRows; i++) &#123; result.append(s.charAt(i)); if (i == 0 || i == numRows - 1) &#123; int j = i + 2 * numRows - 2; while (j &lt; length) &#123; result.append(s.charAt(j)); j += 2 * numRows - 2; &#125; &#125; else &#123; //int Odd = (numRows - 1) + [(numRows -1) - i] int Odd = 2 * numRows - 2 - i; if (Odd &lt; length) result.append(s.charAt(Odd)); int Even = i + 2 * numRows - 2; if (Even &lt; length) result.append(s.charAt(Even)); while (true) &#123; Odd += 2 * numRows - 2; if (Odd &lt; length) result.append(s.charAt(Odd)); else break; Even += 2 * numRows - 2; if (Even &lt; length) result.append(s.charAt(Even)); else break; &#125; &#125; &#125; return result.toString(); &#125; &#125; 需要注意的地方如下：1.对于字符串s，考虑s的长度小于numRows的情况。2.对于每次处理到的下标，除非当前下标是每一行的首个元素，否则需要判断该下标是否越界。3.中间行的奇数位元素的首个元素需要结合当前行进行判断。 提交代码，AC，运行时间53ms，排名84%。这次运气不错，一次运行通过。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Median of Two Sorted Arrays]]></title>
      <url>http://blade6.top/posts/757ce68a/</url>
      <content type="text"><![CDATA[要求出两个有序数组的中位数，试想，如果我们能够求出两个有序数组合并后的第k个数，那么中位数只是一种特殊情况，问题迎刃而解。题目要求时间复杂度要在O(log(m+n))，通常出现对数，应该考虑分治法。 解题思路求解两个有序数组的第k个数：假设给定有序数组A和B,A的前指针aLow和后指针aHigh，B的前指针bLow和bHigh，以及k。求出A数组区间[aLow,aHigh]的中间数A[aMid]，B也做同样操作，同时求出A[aLow,aMid]和B[bLow,bMid]一共有多少个数并赋给HalfPart注意是闭区间，所以A[aMid]和B[bMid]都包含在HalfPart里面，HalfPart=A[aLow,aMid]+B[bLow,bMid]。 然后判断A[aMid]和B[bMid]的大小。如果A[aMid]==B[bMid]，那么判断HalfPart和k的大小。HalfPart&gt;k说明第k个数应该出现在A[aLow,aMid]和B[bLow,bMid]所包含的数里，否则出现在A[aMid+1,aHigh]和B[bMid+1,bHigh]所包含的数里。如果A[aMid]!=B[bMid]，那么也是同样判断HalfPart和k的大小。当A[aMid]k，则说明第k个数不会出现在B[bMid,bHigh]里面，但无法判断第k个数在A中的出现情况。理由如下：如果A[aMid]&lt;B[bMid]&amp;&amp;HalfPart&gt;k，那么我们可以增加一个变量x=aMid，令x自增，直至A[x]==B[bMid]，假设把这两个有序数组进行合并的话，B[bMid]应该出现在x+bMid这个位置上,因为HalfPart&gt;k，同时又有x&gt;aMid，则易知x+bMid=A[aLow,x]+B[bLow,bMid]&gt;HalfPart&gt;k，则B[bMid]是一个合并排序后的第k+u个数（u是未知数），而我们要求的是第k个数，所以第k个数不会出现在B[bMid,bHigh]里面。第k个数有可能出现在A[aLow,x]和B[bLow,bMid-1]这个范围里面。如果HalfPart&lt;=k，则说明第k个数不会出现在A[aLow,aMid]里面，但无法判断在B中的出现情况。理由类似上述。P.S.注意当HalfPart&gt;k时，舍弃了B[bLow,bHigh]，舍弃的是高下标的数据，不会影响我们查找第k个数。但是当HalfPart&lt;=k时，舍弃的是A[aLow,aMid]，这实际修正了我们的查找目标，不再是第k个数，而是第k-(aMid-aLow+1)个数。对于A[aMid]&gt;B[bMid]的情况，相当于互换了A和B的位置，思路还是一样。 分析完毕，可以开始写代码了。1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int length = nums1.length + nums2.length; if (length % 2 == 0) return (findKth(nums1, nums2, length / 2) + findKth(nums1, nums2, length / 2 + 1)) / 2.0; else return findKth(nums1, nums2, (length + 1) / 2); &#125; /* * find the k num in two sorted arrays * recursion */ public int findK(int[] A, int a_low, int a_high, int[] B, int b_low, int b_high, int k) &#123; if (a_low &gt; a_high) return B[b_low + k - 1]; if (b_low &gt; b_high) return A[a_low + k - 1]; //if (a_high == a_low &amp;&amp; b_high == b_low &amp;&amp; A[a_low] == B[b_low]) return A[a_low]; int a_mid = a_low + (a_high - a_low) / 2; int b_mid = b_low + (b_high - b_low) / 2; int half_part = a_mid - a_low + b_mid - b_low + 2; if (A[a_mid] == B[b_mid]) &#123; if (half_part &lt; k) return findK(A, a_mid + 1, a_high, B, b_mid + 1, b_high, k - half_part); else return findK(A, a_low, a_mid, B, b_low, b_mid, k); &#125; else if (A[a_mid] &lt; B[b_mid] ) &#123; if (half_part &lt;= k) return findK(A, a_mid + 1, a_high, B, b_low, b_high, k - (a_mid - a_low + 1)); else return findK(A, a_low, a_high, B, b_low, b_mid - 1, k); &#125; else &#123; if (half_part &lt;= k) return findK(A, a_low, a_high, B, b_mid + 1, b_high, k - (b_mid - b_low + 1)); else return findK(A, a_low, a_mid - 1, B, b_low, b_high, k); &#125; &#125;&#125; 运行代码死在了以下TestCase：[1][1]死亡原因：运行错误，经本地调试发现是栈溢出。实际上是由于代码第26行造成的，死循环最终导致栈溢出。修正方法：将第18行的注释去掉。当两个数组都只剩一个数，且两数组的剩下的数还是同一个数时，则返回这个数。修正后AC通过，运行速度排名45%。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[3Sum]]></title>
      <url>http://blade6.top/posts/92e6a03a/</url>
      <content type="text"><![CDATA[3数和为0问题，对于这个问题，网上一致认为，这个问题是两数和问题的升级版，最终能够优化到O(n^2)级别。 解题思路对于给定数组中的每个下标i，用前指针left指向其下一个数，后指针right指向数组最后的数。如果三个数的和为0，则判断结果是否已出现，如果出现过，不添加，否则添加到结果集。如果三数和小于0，则前指针指向后一个数，否则后指针指向前一个数。根据解题思路，结合网上找到的别人的代码，我迅速地写出了第一个答案：123456789101112131415161718192021222324252627282930313233343536373839public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Arrays.sort(nums); int length = nums.length; for (int i = 0; i &lt; length; i++) &#123; int left = i + 1; int right = length - 1; while (left &lt; right) &#123; int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(nums[i]); list.add(nums[left]); list.add(nums[right]); if (!Compare(result, list)) result.add(list); ++left; --right; &#125; else if (sum &lt; 0) &#123; ++left; &#125; else &#123; --right; &#125; &#125; &#125; return result; &#125; public boolean Compare(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; list) &#123; for(int i = 0; i &lt; result.size(); i++) &#123; List&lt;Integer&gt; test = result.get(i); if (test.contains(list.get(0)) &amp;&amp; test.contains(list.get(1)) &amp;&amp; test.contains(list.get(2))) return true; &#125; return false; &#125; &#125; 通过Compare方法去重。然后死在了以下TestCase：[-4,-2,1,-5,-4,-4,4,-2,0,4,0,-2,3,1,-5,0]死亡原因：程序运行的结果集不正确，缺少[0,0,0]。我自个分析，原因在于Compare方法有错误，如果有一个结果（比如：[-4,4,0]）包含0和两个相反数，则[0,0,0]无法添加到结果集。而且这个方法需要对结果集做一个遍历，效率太低。 自己的代码too young too naive,我决定模仿现成的代码，从网上找到一段代码，Submit：123456789101112131415161718192021222324252627282930public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Arrays.sort(nums); int length = nums.length; for (int i = 0; i &lt; length; i++) &#123; int left = i + 1; int right = length - 1; while (left &lt; right) &#123; int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(nums[i]); list.add(nums[left]); list.add(nums[right]); result.add(list); ++left; --right; &#125; else if (sum &lt; 0) &#123; ++left; &#125; else &#123; --right; &#125; &#125; &#125; Set set = new HashSet&lt;&gt;(result); result = new ArrayList&lt;List&lt;Integer&gt;&gt;(set); return result; &#125;&#125; 这次313个TestCase，死在了第313个，也就是最后一个变态TestCase上：[0,…,0]0的出现次数有数千次之多。。死亡原因：Time Limit Exceeded 这个方法的优点自然是利用集合的无序性来达到去重的效果。缺点则是这是一个事后弥补的方法。对于每次得出的结果，则将该结果加入结果集。最后再对结果集进行筛选去重。为什么不在加入前先去重？ 根据这个TestCase，经过一番反省后，我想出两种办法来去重，第一种是采用过滤方法，第二种是备忘录方法。过滤方法的原理是，对于给定数组nums，如果其中有一个数出现了三次，那么除非这个数是0，否则第三次出现是没有意义的，因为我们最多也只会用到两个。举例来说：[4,-2,-2,-2]三数和为0的结果为[4,-2,-2]，-2在nums中出现了三次，其实出现两次就已经能得到结果[4,-2,-2]了，所以第三个-2是无效的。但0是可以出现三次的。对于任意数，出现了三次以上，就会有很多无效的数，这些数不会改变最终结果，但却会耗费大量运算时间。可以通过对nums进行过滤，剔除出现次数在3次以上的数，使得其出现次数减少至2次，0可以保持3次。第二种方法是备忘录方法，因为最终求和是nums[i]+nums[left]+nums[right]，nums[left]+nums[right]其实存在重复运算的可能性，说不定能存起来，以便下次调用，减少运算次数，但这样一想，感觉方法要走向动态规划了。 这两个idea都是在对nums做过滤，避免因为某个数的出现次数过多而做无用功，在一定程度上能够减少运算次数。但是回到问题本身，问题里给出了一个TestCase：[-1, 0, 1, 2, -1, -4]，上面的两个idea最终都会使输入的数组变成类似这样的形式（任意一个数的出现次数不会超过2次，0可以出现3次）。但这不是最优的形式。因为即使是这样的形式，还是存在重复运算。比如有TestCase：[-4,-4,2,2]。根据解题思路，在整个程序跑的过程中，会出现以下情况：1.当i=0,left=2,right=3时，得到结果[-4,2,2]，将其加入结果集；2.当i=1,left=2,right=2时，得到结果[-4,2,2]，不加入结果集。程序优化的目标就是使得情况2不要出现，因为情况2和情况1是一样的情况。对于每个i，如果array[i]==array[i-1]，那么可以跳过array[i]，因为它的情况和它的前一个数的情况相同。相应地left、right也可以做同样处理。 最终可以编写出如下的代码：1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Arrays.sort(nums); int length = nums.length; for (int i = 0; i &lt; length - 2; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; int left = i + 1; int right = length - 1; while (left &lt; right) &#123; int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(nums[i]); list.add(nums[left]); list.add(nums[right]); result.add(list); ++left; --right; while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) left++; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right--; &#125; else if (sum &lt; 0) &#123; ++left; &#125; else &#123; --right; &#125; &#125; &#125; Set set = new HashSet&lt;&gt;(result); result = new ArrayList&lt;List&lt;Integer&gt;&gt;(set); return result; &#125;&#125; 这个代码被AC了，但是运算速度排在18%左右。仔细想想，我们可以知道实际上对i、left、right进行处理后，情况2是不会出现的，其实也不需要去重了。所以可以对代码做进一步的优化，如下：1234567891011121314151617181920212223242526272829public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Arrays.sort(nums); int length = nums.length; for (int i = 0; i &lt; length - 2; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; int left = i + 1; int right = length - 1; while (left &lt; right) &#123; int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) &#123; result.add(Arrays.asList(nums[i], nums[left], nums[right])); ++left; --right; while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) left++; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right--; &#125; else if (sum &lt; 0) &#123; ++left; &#125; else &#123; --right; &#125; &#125; &#125; return result; &#125;&#125; 提交之后自然是AC了，运算速度排名在65%。 回过头来看我的那两个idea，真是太稚嫩了。nums在排序后，去重其实是很容易做到的，通过指针的移动即可完成，我却还试图费大功夫来实现一个效果不见得好的去重，而忽视排序所带来的便利，一叶障目，不见泰山。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java方法参数——值传递]]></title>
      <url>http://blade6.top/posts/c9c9e9c7/</url>
      <content type="text"><![CDATA[Java中的方法的参数是值传递还是引用传递争论已久，实际上取决于我们怎么定义这两个名词，但如果仅从定义层面去分辨，还是很难有比较好的效果。本文通过实例讲解。 基本数据类型这毫无疑问是值传递，换言之形参和实参互不影响。1234567891011public class Test1 &#123; public static void change(int a)&#123; a=50; &#125; public static void main(String[] args) &#123; int a=10; System.out.print(a + " "); change(a); System.out.print(a); &#125;&#125; 输出结果为：10 10 引用类型（数组、对象）注意形参实际上获得的是实参的一份拷贝，形参和实参都指向同一块内存地址。1234567891011public class Test &#123; public static void change(int []a)&#123; a[0]=50; &#125; public static void main(String[] args) &#123; int []a=&#123;10,20&#125;; System.out.print(a[0] + " "); change(a); System.out.print(a[0]); &#125;&#125; 输出结果为：10 50 String类String类实际上和引用类型一样，但又有一些不同。不同的地方在于String类的内容不可变，这就是String类之所以特殊的地方。123456789101112public class Test &#123; public static void change(String s2)&#123; s2="goodbye"; &#125; public static void main(String[] args) &#123; String s1=new String("hello"); System.out.print(s1 + " "); change(s1); System.out.print(s1); &#125;&#125; 输出结果为：hello hello当调用change()方法时，把s1的值（”hello”的内存地址）传递过去，s2的值将会和s1的值相同；当执行语句s2=”goodbye”时，将”goodbye”的内存地址赋给s2，此时s2的值和s1的值不再一致。所以s1的内容没有发生变化。P.S.而对于对象、数组，它们的数据域不一定是不可变对象，所以是可以通过使用形参改变的，于是出现了String类表现特殊的情况。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Longest Palindromic Substring]]></title>
      <url>http://blade6.top/posts/8872b998/</url>
      <content type="text"><![CDATA[问题：给定字符串s，求出其最长回文子串。方法一：动态规划。思想描述：假设 s[i][j] 表示字符串 s 下标从 i 到 j 的子串，如果该子串是回文子串，则令 dp[i][j] 为 true 。如果我们已经得到了最优解，这个最优解是 s[i][j] ，无疑 dp[i][j] = true 。而 dp[i][j]=true 实际上等价于 dp[i+1][j-1] = true &amp;&amp; s[i] == s[j] ，这就是推导式。考虑 i+1 == j-1 ， i+1 == (j-1)-1 ，分别对应回文子串长度为1和为2的情况，这就是基准情况：a. dp[i][i] = trueb. dp[i][i+1] = true if s[i] == s[i+1] 代码如下：12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; //Dynamic Programming public String longestPalindrome(String s) &#123; if(s.length()==0 || s.length() == 1) return s; int length = s.length(); int max = 1; String result = "" +s.charAt(0); boolean[][] dp = new boolean[length][length]; for(int i=0;i&lt;length;i++) dp[i][i] = true; for(int i=0;i&lt;length-1;i++)&#123; if(s.charAt(i) == s.charAt(i+1))&#123; dp[i][i+1] = true; if(max != 2)&#123; max = 2; result = s.substring(i, i+2); &#125; &#125; &#125; for(int i = length - 3; i &gt;= 0; i--)&#123; for(int j = i+2; j &lt; length; j++)&#123; if(dp[i+1][j-1] &amp;&amp; s.charAt(i) == s.charAt(j))&#123; dp[i][j] = true; if(j-i+1 &gt; max)&#123; max = j-i+1; result = s.substring(i, j+1); &#125; &#125;else&#123; dp[i][j] = false; &#125; &#125; &#125; return result; &#125; &#125; 需要注意的地方：实现动态规划时，需要注意边界，从哪里开始，到哪里结束。 方法二：中心扩展。思想描述：回文串是中心对称的，以 s[i] 为中心，用两个指针向两侧扩展判断是否相等可以得到以s[i]为中心的回文子串，对s的每个字符重复此操作，最终可以求得最大回文子串。 代码如下：123456789101112131415161718192021222324252627282930public class Solution &#123; public String longestPalindrome(String s)&#123; if(s.length() == 1 || s.length() == 0) return s; int max = 1; int ans; String result = "" +s.charAt(0); for(int i=1;i&lt;s.length();i++)&#123; ans = Math.max(PS_length(s, i-1, i+1), PS_length(s, i-1, i)); if(ans &gt; max)&#123; max = ans; if(ans % 2 == 0) result = s.substring(i-ans/2, i+ans/2); else result = s.substring(i-ans/2, i+ans/2+1); &#125; &#125; return result; &#125; //PS is short for Palindromic Substring public int PS_length(String s, int i, int j)&#123; while(i &gt;=0 &amp;&amp; j &lt; s.length())&#123; if(s.charAt(i)!=s.charAt(j)) break; --i; ++j; &#125; return j-i-1; //return (j-i-1)+2 &#125; &#125; 小trick：在求子串时，下标可以通过实例来明确。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[回车符与换行符]]></title>
      <url>http://blade6.top/posts/285ba2a7/</url>
      <content type="text"><![CDATA[昨天晚上做NLP的时候，需要对文件做一些预处理。然后无意中发现一点小问题。通过用python和java分别对文件进行输出文本行数，发现不同。输入文本文件:199801.txt下面是Java实现的代码：12345678910111213141516171819202122232425import java.io.*;import java.util.*;public class test &#123; public static void main(String[] args) throws FileNotFoundException &#123; java.io.File in_file = new java.io.File("199801.txt"); Scanner input = new Scanner(in_file); java.io.File out_file = new java.io.File("test.txt"); java.io.PrintWriter output = new java.io.PrintWriter(out_file); //p_num表示文本总行数，q_num表示存在有效文字的行数 int p_num = 0,q_num = 0; while(input.hasNextLine())&#123; String line = input.nextLine(); ++p_num; if("".equals(line))&#123; continue; &#125; ++q_num; output.println(q_num+" "+line); &#125; System.out.println(p_num+" "+q_num); input.close(); output.close(); System.out.println("Done!"); &#125;&#125; 控制台上输出：23064 19484Done!用Python实现的情况如下：1234567891011121314151617181920f = open('199801.txt','r')g = open('test1.txt','w')p_num = 0q_num = 0while True: line = f.readline() if len(line): p_num += 1 if line != '\n': continue q_num += 1 g.write(str(q_num)+" "+line) else: breakf.close()g.close()print p_num,q_num 控制台输出：22722 19538 可以观察到总行数Java这边较大，有效行数Python这边较大。我决定首先解决有效行数不一致的问题。因为我在代码中还写了把有效行写成文件的内容，所以我决定检查一下test.txt和text1.txt文件有什么不同。手动打开两个文件，通过粗略估计+二分搜索法，确定第一次输出不同在第341行。(P.S.有效行是指该行中存在文字。)text.txt line341: 341 19980101-07-007-001/m 细语/n （/w 中国画/n ）/w tex1.txt line341: 341 也就是text1.txt的341行实际上不是有效行，说明Python代码中判断是否是有效行的逻辑有错误。于是我认为输入的文本文件中可能混有回车符和换行符。（P.S.这里考虑到文章的整体的流畅性，省略了很多细节。实际上最初我认为问题出在Java，因为我引入了C++语言，统计文本行数的结果和Python是一致的。当时我认为问题出在Java代码中的input.nextLine()处，所以搜索了很多关于这个函数返回值的问题，知道了nextLine()会吞掉换行符。然后通过百度换行符，我又了解到了回车符这个概念，其实以前学过，忘记了。。）于是我对Python代码稍加修改，增加在原代码13行和14行之间:1234if q_num == 341: print len(line) if line == '\r\n': print 'bingo' 控制台显示： 2bingo22722 19538 于是判断出问题的关键在于’\r’和’\n’。于是我对Python代码进行了再次修改：1234567891011121314151617181920f = open('199801.txt','r')g = open('test1.txt','w')p_num = 0q_num = 0while True: line = f.readline() if len(line): p_num += 1 if line == '\n' or line == '\r\n' or line == '\r': continue q_num += 1 g.write(str(q_num)+" "+line) else: breakf.close()g.close()print p_num,q_num 再执行了一遍，控制台输出： 22722 19485 为什么有效行数仍然多了一行？首先需要找出有问题的行，于是我写了一段Python代码，避免手工排查：（P.S.其实第一次手工排查前我就尝试写脚本排查，无奈因为不知道回车符，导致没有写出有效的脚本）123456789101112131415161718192021f = open('test1.txt','r')g = open('D:\\java\\Dev\\test.txt','r')num = 0while True: line1 = f.readline() line2 = g.readline() num += 1 if line1 != line2: if len(line1) == len(line2)+1: continue else: break if not len(line1): breakprint num,len(line1),len(line2)f.close()g.close() 因为text1.txt有些行有\r，所以有些行的长度会比text.txt中的对应行大1，但实际上有效内容是一致的，所以代码中进行了忽略这样的行。执行后控制台输出： 1265 8 77 可以看到两个文件是在第1265行出现分歧的。有了之前的经验教训，我怀疑text1.txt的1265行的内容是”1265 \r\r\n”，通过对脚本的代码稍加修改：12345678910111213141516171819202122232425f = open('test1.txt','r')g = open('D:\\java\\Dev\\test.txt','r')num = 0while True: line1 = f.readline() line2 = g.readline() num += 1 if line1 != line2: if len(line1) == len(line2)+1: continue else: if num == 1265: print len(line1) if line1 == "1265 \r\r\n": print 'bingo' break if not len(line1): breakprint num,len(line1),len(line2)f.close()g.close() 控制台输出： 8bingo1265 8 77 证明我的判断是正确的。至此，解决了有效行数不一致的问题。那么为什么总行数会不相等呢？实际上，Python中f.readline()返回一行，不对这行做任何处理。而Java中input.nextLine()会获取从当前位置开始到一个结束符前的内容，然后去掉末尾的结束符返回。通过对本文Java代码稍加改写，可以发现’\r’，’\n’都会被认为是结束符。比如：当文本中有一行的内容为”\r\n”时，f.readline()会返回”\r\n”，行数加1。input.nextLine()返回”\r”前的内容，也就是””，行数加1；然后input.nextLine()会返回”\n”前的内容，也是””，行数加1。读取这一行后，Java和Python的行数就出现不一致了。 综上，对于Java中的Scanner的nextLine()方法，其名字中的nextline并不是真正意义上的下一行，准确地说应该是从当前位置到下一个结束符之前的内容。Python的readline()方法返回真正意义上的一行，所以在对行做处理时，需要考虑行末是换行符或回车+换行符的情况。 附上回车符与换行符的区别： CR：CarriageReturn，回车符，用’\r’表示，16进制代码为0x0D，光标移动到当前行的最左边。LF：LineFeed，换行符，用’\n’表示，16进制代码为0x0A，把光标向下移动一行。 不同操作系统表示一行的结束不同：Unix、Linux：\n表示回车+换行，\r无意义Windows、DOS：\r\n表示回车+换行，顺序不能颠倒Mac：\r表示回车+换行(P.S.Mac OS 9以及之前的系统的换行符是CR，从Mac OS X（后来改名为OS X）开始的换行符是LF，和Unix/Linux统一了。) 影响：（1）一个直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；（2）而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。（3）Linux保存的文件在windows上用记事本看的话会出现黑点。 相互转换：在linux下，命令unix2dos 是把linux文件格式转换成windows文件格式，命令dos2unix 是把windows格式转换成linux文件格式。 在不同平台间使用FTP软件传送文件时, 在ascii文本模式传输模式下, 一些FTP客户端程序会自动对换行格式进行转换. 经过这种传输的文件字节数可能会发生变化.如果你不想ftp修改原文件, 可以使用bin模式(二进制模式)传输文本。一个程序在windows上运行就生成CR/LF换行格式的文本文件，而在Linux上运行就生成LF格式换行的文本文件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Hexo搭建个人博客小记]]></title>
      <url>http://blade6.top/posts/21637/</url>
      <content type="text"><![CDATA[今天购买了域名，基本上完成了博客的各项配置，接下来就可以开始写博客了。因为目前暂时没有什么干货，只好把建站的一些过程发上来撑撑场面，~_~ 动机其实在今年年初的时候，师兄就让我们搭建自己的博客。那个时候的我，完全0基础。硬是一个寒假在虚拟机上搭建了一个博客，那个时候只是把它当成作业来完成的，做得十分简陋，这里就不po上来献丑了。做好之后就搁置了。直到这个学期，前几周，计算机英语老师说计算机专业的学生怎么能没有自己的个人网站，于是我萌生了搭建博客网站的想法。因为现在Nodejs+Hexo+Github Pages搭建博客很流行，于是我也加入了这股潮流。说干就干，网上的资料十分多，可能是每个搭建博客的都写了一篇建站日志, : ) 建站大致过程 安装Git Bash,Nodejs,Hexo. GitHub新建repo，并设置SSH. 下载安装next主题，并按照NexT的内容进行各项参数的设置。 多说评论、分享、热评文章 LeanCloud阅读次数统计 Local Search 购买域名。 SEO推广 文章链接唯一永久化 更改阅读全文样式打开\themes\next\source\css\_common\components\post\post-button.styl文件，修改成1234567891011121314151617181920212223242526.post-button &#123; margin-top: 50px; .btn &#123; display: inline-block; border-width: 2px; border-style: solid; border-color: rgb(85,85,85); padding: 0 20px; line-height: 2; font-size: 14px; color: #555555; text-decoration: none; &#125; .btn:hover &#123; color: white; background-color: #222222; &#125;&#125; 参考资料如何使用10个小时搭建出个人域名而又Geek的独立博客使用Hexo搭建个人博客(基于hexo3.0)Hexo系列教程Hexo+nexT主题搭建个人博客使用Hexo搭建博客的深度优化将hexo博客同时托管到github和codinghexo提交搜索引擎 在此致谢所有无形中帮助到我的人，谢谢你们的分享。互联网精神万岁！]]></content>
    </entry>

    
  
  
</search>
